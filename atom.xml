<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[HiDBA | 林晓嘉]]></title>
  <subtitle><![CDATA[Technology change our life.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hidba.ga/"/>
  <updated>2014-12-26T17:20:54.593Z</updated>
  <id>http://hidba.ga/</id>
  
  <author>
    <name><![CDATA[林晓嘉]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[MySQL案例]之一把看不见的锁后续(metadata lock)]]></title>
    <link href="http://hidba.ga/2014/12/26/a-invisible-lock2/"/>
    <id>http://hidba.ga/2014/12/26/a-invisible-lock2/</id>
    <published>2014-12-26T13:19:37.000Z</published>
    <updated>2014-12-26T17:20:09.000Z</updated>
    <content type="html"><![CDATA[<p>今天MySQL过载保护又立功干掉了一堆堵塞的SQL，到后台一看，发现了一大堆熟悉的”Waiting for table metadata lock”。之前刚好写过一篇关于metadata lock相关问题处理的<a href="http://hidba.ga/2014/09/20/a-invisible-lock/" target="_blank" rel="external">文章</a>，有兴趣的同学自己点进去看看。</p>
<h2 id="关于metadata_lock说明">关于metadata lock说明</h2>
<p>在正式说明问题之前我们先来回顾下MySQL的metadata lock。metadata lock是MySQL在5.5.3版本以后引入的，在那之前MySQL的元数据锁的颗粒度是statement级别，在5.5.3版本引入metadata lock以后变成是transaction级别，改造的目的是为了解决著名的BUG989，也就是说可能出现slave同步复制失败。简单来说就是因为MySQL二进制日志是顺序写，如果在事务未提交前执行了DDL，则二进制日志先记录了DDL再记录DML的语句就可能导致slave同步应用失败。具体参见<a href="http://bugs.mysql.com/bug.php?id=989" target="_blank" rel="external">MySQL BUG989</a>。关于metadata lock的说明可以看<a href="http://dev.mysql.com/doc/refman/5.5/en/metadata-locking.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="问题说在前面">问题说在前面</h2>
<p>这次发现大量的SELECT执行超过300秒，状态都是”Waiting for table metadata lock”。按照前面的说明，metadata lock应该是与DDL加锁互斥，而DDL加的是一把write access read lock，理论上是不会堵塞查询请求。而后在测试过程中又遇到几个问题，这里就一一描述下：</p>
<p><strong>问题一：为什么出现上文提及的select会需要等待metadata lock加锁？</strong><br><strong>问题二：在测试过程中发现模拟同样的操作，有些select无需等待metadata lock加锁？</strong><br><strong>问题三：为什么有些DDL不会有metadata lock等待？同样的数据表在5.5与5.6版本下实验结果不一致？</strong></p>
<h2 id="问题一过程重现">问题一过程重现</h2>
<p>这个就是这次发生的问题，这里做个简答的现场重现</p>
<p><em>session A</em> //开启显性事务，执行一个查询后不要提交</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select * from a;</span></div><div class="line">+------+</div><div class="line"><span class="header">| id   |</span></div><div class="line">+------+</div><div class="line"><span class="header">|    1 | </span></div><div class="line">+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p><em>session B</em> //执行一个DDL</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table a add id2 int;</div><div class="line"><span class="keyword">...</span>堵塞中</div></pre></td></tr></table></figure>

<p><em>session C</em> //执行一个查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from a;</div><div class="line"><span class="keyword">...</span>堵塞中</div></pre></td></tr></table></figure>

<p><em>session D</em> //查看进程状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show processlist;</span></div><div class="line">+-----+------+-----------+--------------+---------+------+---------------------------------+---------------------------+-----------+---------------+-----------+</div><div class="line"><span class="header">| Id  | User | Host      | db           | Command | Time | State                           | Info                      | Rows_sent | Rows_examined | Rows_read |</span></div><div class="line">+-----+------+-----------+--------------+---------+------+---------------------------------+---------------------------+-----------+---------------+-----------+</div><div class="line">| 181 | root | localhost | join<span class="emphasis">_test_</span>db | Sleep   |  169 |                                 | NULL                      |         1 |             1 |         2 | </div><div class="line">| 182 | root | localhost | join<span class="emphasis">_test_</span>db | Query   |   96 | Waiting for table metadata lock | alter table a add id2 int |         0 |             0 |         2 | </div><div class="line">| 184 | root | localhost | join<span class="emphasis">_test_</span>db | Query   |   50 | Waiting for table metadata lock | select * from a           |         0 |             0 |         1 | </div><div class="line"><span class="header">| 185 | root | localhost | join_test_db | Query   |    0 | NULL                            | show processlist          |         0 |             0 |         5 | </span></div><div class="line">+-----+------+-----------+--------------+---------+------+---------------------------------+---------------------------+-----------+---------------+-----------+</div><div class="line">4 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>然后session A提交以后，session B跟session C就都解锁开始执行。</p>
<h2 id="问题二过程重现">问题二过程重现</h2>
<p><em>session A</em> //开启显性事务，执行一个查询后不要提交</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select * from a;</span></div><div class="line">+------+------+</div><div class="line"><span class="header">| id   | id2  |</span></div><div class="line">+------+------+</div><div class="line"><span class="header">|    1 | NULL | </span></div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p><em>session B</em> //执行一个DDL</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table a add id3 int;</div><div class="line"><span class="keyword">...</span>堵塞中</div></pre></td></tr></table></figure>

<p><em>session C</em> //执行一个查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; mysql&gt; select * from a;          </span></div><div class="line">+------+------+</div><div class="line"><span class="header">| id   | id2  |</span></div><div class="line">+------+------+</div><div class="line"><span class="header">|    1 | NULL | </span></div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p><em>session D</em> //查看进程状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show processlist;</span></div><div class="line">+-----+------+-----------+--------------+---------+------+---------------------------------+---------------------------+-----------+---------------+-----------+</div><div class="line"><span class="header">| Id  | User | Host      | db           | Command | Time | State                           | Info                      | Rows_sent | Rows_examined | Rows_read |</span></div><div class="line">+-----+------+-----------+--------------+---------+------+---------------------------------+---------------------------+-----------+---------------+-----------+</div><div class="line">| 181 | root | localhost | join<span class="emphasis">_test_</span>db | Sleep   |   15 |                                 | NULL                      |         1 |             1 |         2 | </div><div class="line">| 182 | root | localhost | join<span class="emphasis">_test_</span>db | Query   |   11 | Waiting for table metadata lock | alter table a add id3 int |         0 |             0 |         2 | </div><div class="line">| 184 | root | localhost | join<span class="emphasis">_test_</span>db | Sleep   |    7 |                                 | NULL                      |         0 |             0 |         2 | </div><div class="line"><span class="header">| 185 | root | localhost | join_test_db | Query   |    0 | NULL                            | show processlist          |         0 |             0 |         5 | </span></div><div class="line">+-----+------+-----------+--------------+---------+------+---------------------------------+---------------------------+-----------+---------------+-----------+</div><div class="line">4 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>然后session A提交以后，session B就解锁开始执行。</p>
<h2 id="问题三过程重现">问题三过程重现</h2>
<p>第三个问题是在一张<strong>两千万的大表</strong>上测试发现的，在测试的过程中发现DDL的状态并未处于”Waiting for table metadata lock”，而是开始执行，在查看进程的时候已经是处于”copy to tmp table”状态。<br>更奇怪的是同样的数据在不同版本的数据库中，实验结果是不一样的。在5.5.28的版本中出现如上面描述的未出现”Waiting for table metadata lock”，但是在5.6.21版本执行中出现了跟上面的问题一一样的状况。</p>
<p><strong>MySQL5.5.28实验</strong></p>
<p><em>session A</em> //开启显性事务，执行一个查询后不要提交</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;         </div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select * from t_user_log limit 1 ;</span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| id | uid       | username             | appname      | loginip         | loginlocation                     | logintime  | logintype | useragent |</span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">|  1 | 101603700 | xxxxxx@17173.com     | 发号中心     | xx.246.216.xxx  | 湖南省郴州市 (永兴)电信           | 1406822402 |         1 |           | </span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p><em>session B</em> //执行一个DDL</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">mysql&gt;</span> alter table t_user_log add xxx int;</span></div></pre></td></tr></table></figure>

<p><em>session C</em> //执行一个查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select * from t_user_log limit 1 ;</span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| id | uid       | username             | appname      | loginip         | loginlocation                     | logintime  | logintype | useragent |</span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">|  1 | 101603700 | xxxxxx@17173.com     | 发号中心     | xx.246.216.xxx  | 湖南省郴州市 (永兴)电信           | 1406822402 |         1 |           | </span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p><em>session D</em> //查看进程状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show processlist;</div><div class="line">+-----+------+-----------+--------------+---------+------+-------------------+------------------------------------+-----------+---------------+-----------+</div><div class="line">| <span class="class">Id</span>  | <span class="class">User</span> | <span class="class">Host</span>      <span class="localvars">| db           |</span> <span class="class">Command</span> | <span class="class">Time</span> | <span class="class">State</span>             | <span class="class">Info</span>                               | <span class="class">Rows_sent</span> | <span class="class">Rows_examined</span> | <span class="class">Rows_read</span> |</div><div class="line">+-----+------+-----------+--------------+---------+------+-------------------+------------------------------------+-----------+---------------+-----------+</div><div class="line">| <span class="number">181</span> <span class="localvars">| root | localhost | join_test_db |</span> <span class="class">Sleep</span>   |   <span class="number">28</span> |                   | <span class="class">NULL</span>                               |         <span class="number">1</span> |             <span class="number">1</span> |         <span class="number">2</span> | </div><div class="line">| <span class="number">182</span> <span class="localvars">| root | localhost | join_test_db |</span> <span class="class">Query</span>   |   <span class="number">15</span> <span class="localvars">| copy to tmp table | alter table t_user_log add xxx int |</span>         <span class="number">0</span> |             <span class="number">0</span> |    <span class="number">377166</span> | </div><div class="line">| <span class="number">184</span> <span class="localvars">| root | localhost | join_test_db |</span> <span class="class">Sleep</span>   |    <span class="number">5</span> |                   | <span class="class">NULL</span>                               |         <span class="number">1</span> |             <span class="number">1</span> |         <span class="number">2</span> | </div><div class="line">| <span class="number">185</span> <span class="localvars">| root | localhost | join_test_db |</span> <span class="class">Query</span>   |    <span class="number">0</span> | <span class="class">NULL</span>              <span class="localvars">| show processlist                   |</span>         <span class="number">0</span> |             <span class="number">0</span> |         <span class="number">5</span> | </div><div class="line">+-----+------+-----------+--------------+---------+------+-------------------+------------------------------------+-----------+---------------+-----------+</div><div class="line"><span class="number">4</span> rows in set (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure>

<p><strong>MySQL5.6.21实验</strong></p>
<p><em>session A</em> //开启显性事务，执行一个查询后不要提交</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;         </div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select * from t_user_log limit 1 ;</span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| id | uid       | username             | appname      | loginip         | loginlocation                     | logintime  | logintype | useragent |</span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">|  1 | 101603700 | xxxxxx@17173.com     | 发号中心     | xx.246.216.xxx  | 湖南省郴州市 (永兴)电信           | 1406822402 |         1 |           | </span></div><div class="line">+----+-----------+----------------------+--------------+-----------------+-----------------------------------+------------+-----------+-----------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p><em>session B</em> //执行一个DDL</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table t_user_log add xxx int;</div><div class="line"><span class="keyword">...</span>堵塞中</div></pre></td></tr></table></figure>

<p><em>session C</em> //执行一个查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_user_log limit <span class="number">1</span> ;</div><div class="line"><span class="keyword">...</span>堵塞中</div></pre></td></tr></table></figure>

<p><em>session D</em> //查看进程状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show processlist;</span></div><div class="line">+----+------+-----------+--------------+---------+------+---------------------------------+------------------------------------+</div><div class="line"><span class="header">| Id | User | Host      | db           | Command | Time | State                           | Info                               |</span></div><div class="line">+----+------+-----------+--------------+---------+------+---------------------------------+------------------------------------+</div><div class="line">| 38 | root | localhost | join<span class="emphasis">_test_</span>db | Sleep   |   18 |                                 | NULL                               | </div><div class="line">| 39 | root | localhost | join<span class="emphasis">_test_</span>db | Query   |   12 | Waiting for table metadata lock | alter table t<span class="emphasis">_user_</span>log add xxx int | </div><div class="line">| 40 | root | localhost | join<span class="emphasis">_test_</span>db | Query   |    5 | Waiting for table metadata lock | select * from t<span class="emphasis">_user_</span>log limit 1   | </div><div class="line"><span class="header">| 41 | root | localhost | join_test_db | Query   |    0 | init                            | show processlist                   | </span></div><div class="line">+----+------+-----------+--------------+---------+------+---------------------------------+------------------------------------+</div><div class="line">4 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>同样的实验在不同的数据库版本中结果居然是不一样的，这个又是为什么呢？</p>
<h2 id="问题一答案">问题一答案</h2>
<p>在第一个问题的实验中我们发现一个未提交的事务使得后续的DDL以及SELECT请求都堵塞了，一旦commit以后，后面的两个请求都能迅速执行，那么我们就来可以借助profile工具来看下到底两个请求分别是在什么地方发生了等待。</p>
<p><strong>session B</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show profile;</div><div class="line">+------------------------------+-----------+</div><div class="line">| <span class="class">Status</span>                       | <span class="class">Duration</span>  |</div><div class="line">+------------------------------+-----------+</div><div class="line"><span class="localvars">| starting                     |</span>  <span class="number">0.000046</span> | </div><div class="line"><span class="localvars">| checking permissions         |</span>  <span class="number">0.000004</span> | </div><div class="line"><span class="localvars">| checking permissions         |</span>  <span class="number">0.000004</span> | </div><div class="line"><span class="localvars">| init                         |</span>  <span class="number">0.000008</span> | </div><div class="line">| <span class="class">Opening</span> tables               |  <span class="number">0.000052</span> | </div><div class="line">| <span class="class">System</span> lock                  |  <span class="number">0.000009</span> | </div><div class="line"><span class="localvars">| setup                        |</span>  <span class="number">0.000020</span> | </div><div class="line"><span class="localvars">| creating table               |</span>  <span class="number">0.016214</span> | </div><div class="line">| <span class="class">After</span> create                 |  <span class="number">0.000051</span> | </div><div class="line"><span class="localvars">| copy to tmp table            |</span>  <span class="number">0.000165</span> | </div><div class="line"><span class="localvars">| rename result table          |</span> <span class="number">16.229622</span> | </div><div class="line"><span class="localvars">| end                          |</span>  <span class="number">0.000134</span> | </div><div class="line">| <span class="class">Waiting</span> for query cache lock |  <span class="number">0.000003</span> | </div><div class="line"><span class="localvars">| end                          |</span>  <span class="number">0.000013</span> | </div><div class="line"><span class="localvars">| query end                    |</span>  <span class="number">0.000003</span> | </div><div class="line"><span class="localvars">| closing tables               |</span>  <span class="number">0.000011</span> | </div><div class="line"><span class="localvars">| freeing items                |</span>  <span class="number">0.000017</span> | </div><div class="line"><span class="localvars">| cleaning up                  |</span>  <span class="number">0.000003</span> | </div><div class="line">+------------------------------+-----------+</div><div class="line"><span class="number">18</span> rows in set (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure>

<p><strong>session C</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show profile;</div><div class="line">+--------------------------------+----------+</div><div class="line">| <span class="class">Status</span>                         | <span class="class">Duration</span> |</div><div class="line">+--------------------------------+----------+</div><div class="line"><span class="localvars">| starting                       |</span> <span class="number">0.000016</span> | </div><div class="line">| <span class="class">Waiting</span> for query cache lock   | <span class="number">0.000002</span> | </div><div class="line">| <span class="class">Waiting</span> on query cache mutex   | <span class="number">0.000002</span> | </div><div class="line"><span class="localvars">| checking query cache for query |</span> <span class="number">0.000033</span> | </div><div class="line"><span class="localvars">| checking permissions           |</span> <span class="number">0.000006</span> | </div><div class="line">| <span class="class">Opening</span> tables                 | <span class="number">8.808491</span> | </div><div class="line">| <span class="class">System</span> lock                    | <span class="number">0.000009</span> | </div><div class="line">| <span class="class">Waiting</span> for query cache lock   | <span class="number">0.000002</span> | </div><div class="line">| <span class="class">Waiting</span> on query cache mutex   | <span class="number">0.000017</span> | </div><div class="line"><span class="localvars">| init                           |</span> <span class="number">0.000016</span> | </div><div class="line"><span class="localvars">| optimizing                     |</span> <span class="number">0.000003</span> | </div><div class="line"><span class="localvars">| statistics                     |</span> <span class="number">0.000009</span> | </div><div class="line"><span class="localvars">| preparing                      |</span> <span class="number">0.000008</span> | </div><div class="line"><span class="localvars">| executing                      |</span> <span class="number">0.000002</span> | </div><div class="line">| <span class="class">Sending</span> data                   | <span class="number">0.000040</span> | </div><div class="line"><span class="localvars">| end                            |</span> <span class="number">0.000003</span> | </div><div class="line"><span class="localvars">| query end                      |</span> <span class="number">0.000003</span> | </div><div class="line"><span class="localvars">| closing tables                 |</span> <span class="number">0.000005</span> | </div><div class="line"><span class="localvars">| freeing items                  |</span> <span class="number">0.000005</span> | </div><div class="line">| <span class="class">Waiting</span> for query cache lock   | <span class="number">0.000002</span> | </div><div class="line">| <span class="class">Waiting</span> on query cache mutex   | <span class="number">0.000001</span> | </div><div class="line"><span class="localvars">| freeing items                  |</span> <span class="number">0.000008</span> | </div><div class="line">| <span class="class">Waiting</span> for query cache lock   | <span class="number">0.000001</span> | </div><div class="line">| <span class="class">Waiting</span> on query cache mutex   | <span class="number">0.000001</span> | </div><div class="line"><span class="localvars">| freeing items                  |</span> <span class="number">0.000002</span> | </div><div class="line"><span class="localvars">| storing result in query cache  |</span> <span class="number">0.000002</span> | </div><div class="line"><span class="localvars">| logging slow query             |</span> <span class="number">0.000001</span> | </div><div class="line"><span class="localvars">| cleaning up                    |</span> <span class="number">0.000002</span> | </div><div class="line">+--------------------------------+----------+</div><div class="line"><span class="number">28</span> rows in set (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure>

<p>从上面profile的结果我们可以的只session B是在rename result table的时候发生等待，也就是说metadata lock确实堵塞了修改表结构的操作。<br>而session C先是检查query cache后发现没有命中，然后才在Opening tables的时候发生了等待，而实际上也就是说<strong>rename result table这个步骤堵塞了Opening tables的执行</strong>，这个也能理解，就像X与S互斥一样。（在MySQL 5.6的版本中profile输出略有不同，会在rename result table下面显示Waiting for table metadata lock的具体等待时间以及等待时长）<br>这样我们就发现了第一个问题的答案，那么第二个问题也不难发现，那就是session C执行SELECT过程中没有执行Opening tables步骤，也就是说直接在query cache中命中，下面我们继续验证。</p>
<h2 id="问题二答案">问题二答案</h2>
<p>我们继续看下问题二的session C的profile<br><strong>session C</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show profile;            </span></div><div class="line">+--------------------------------+----------+</div><div class="line"><span class="header">| Status                         | Duration |</span></div><div class="line">+--------------------------------+----------+</div><div class="line">| starting                       | 0.000015 | </div><div class="line">| Waiting for query cache lock   | 0.000002 | </div><div class="line">| Waiting on query cache mutex   | 0.000002 | </div><div class="line">| checking query cache for query | 0.000006 | </div><div class="line">| checking privileges on cached  | 0.000003 | </div><div class="line">| checking permissions           | 0.000007 | </div><div class="line">| sending cached result to clien | 0.000011 | </div><div class="line">| logging slow query             | 0.000002 | </div><div class="line"><span class="header">| cleaning up                    | 0.000001 | </span></div><div class="line">+--------------------------------+----------+</div><div class="line">9 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>结果不出意料之外，SELECT请求没有出现等待metadata lock的情况是因为query cache能够命中而无需执行Opening tables。</p>
<h2 id="问题三答案">问题三答案</h2>
<p>我们刚在问题三的MySQL 5.5.28实验中发现session B中的DDL请求并未处于”Waiting for table metadata lock”而是开始执行并处于”copy to tmp table”状态。但是经过前面两个问题的解析，我们就能明白其实并不是session B的DDL没有等待metadata lock加锁，而是加锁是在”rename result table”步骤，处于”copy to tmp table”之后，而前面我们也说了问题三的实验对象是一张<strong>两千万行的大表</strong>，所以临时表环境耗时很长，因此我们在show processlist的时候发现该进程处于”copy to tmp table”而不是”Waiting for table metadata lock”状态，造成了没有等待加锁的假象，其实继续等待下去，等待临时表生成完毕还是会进入等待加锁状态。</p>
<p>那为什么同样一张大表，在MySQL 5.6.21中却直接进入”Waiting for table metadata lock”呢？我们猜测跟MySQL 5.6的online DDL特性有关，下面我们还是通过profile来验证。</p>
<p><strong>session B</strong> </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show profile;                    </div><div class="line">+--------------------------------+----------+</div><div class="line">| <span class="class">Status</span>                         | <span class="class">Duration</span> |</div><div class="line">+--------------------------------+----------+</div><div class="line"><span class="localvars">| starting                       |</span> <span class="number">0.000065</span> | </div><div class="line"><span class="localvars">| checking permissions           |</span> <span class="number">0.000004</span> | </div><div class="line"><span class="localvars">| checking permissions           |</span> <span class="number">0.000005</span> | </div><div class="line"><span class="localvars">| init                           |</span> <span class="number">0.000003</span> | </div><div class="line">| <span class="class">Opening</span> tables                 | <span class="number">0.000035</span> | </div><div class="line"><span class="localvars">| setup                          |</span> <span class="number">0.000030</span> | </div><div class="line"><span class="localvars">| creating table                 |</span> <span class="number">0.000663</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000078</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.003192</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000012</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.002947</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000014</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.002883</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000012</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.002999</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000012</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.002944</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000010</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.002934</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000008</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.002937</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000009</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">1.002954</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000009</span> | </div><div class="line">| <span class="class">Waiting</span> for table metadata loc | <span class="number">0.247139</span> | </div><div class="line">| <span class="class">After</span> create                   | <span class="number">0.000021</span> | </div><div class="line">| <span class="class">System</span> lock                    | <span class="number">0.000015</span> | </div><div class="line"><span class="localvars">| preparing for alter table      |</span> <span class="number">0.001604</span> | </div><div class="line"><span class="localvars">| altering table                 |</span> <span class="number">0.785378</span> | </div><div class="line"><span class="localvars">| committing alter table to stor |</span> <span class="number">0.032014</span> | </div><div class="line"><span class="localvars">| end                            |</span> <span class="number">0.000025</span> | </div><div class="line"><span class="localvars">| query end                      |</span> <span class="number">0.000154</span> | </div><div class="line"><span class="localvars">| closing tables                 |</span> <span class="number">0.000010</span> | </div><div class="line"><span class="localvars">| freeing items                  |</span> <span class="number">0.000017</span> | </div><div class="line"><span class="localvars">| cleaning up                    |</span> <span class="number">0.000018</span> | </div><div class="line">+--------------------------------+----------+</div><div class="line"><span class="number">35</span> rows in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure>

<p>我们在profile中并未见”copy to tmp table”的步骤，这也就是为什么在一开始测试的5.6.21版本中不会像5.5.28版本那样需要在”copy to tmp table”等待那么久。下面我们关闭掉online DDL特性再来一试。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">mysql&gt; <span class="type">set</span> old_alter_table = <span class="number">1</span>;</div><div class="line"><span class="type">Query</span> <span class="type">OK</span>, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">00</span> sec)</div><div class="line"></div><div class="line">mysql&gt; show profile;                     </div><div class="line">+--------------------------------+----------+</div><div class="line">| <span class="type">Status</span>                         | <span class="type">Duration</span> |</div><div class="line">+--------------------------------+----------+</div><div class="line">| starting                       | <span class="number">0</span>.<span class="number">000055</span> | </div><div class="line">| checking permissions           | <span class="number">0</span>.<span class="number">000005</span> | </div><div class="line">| checking permissions           | <span class="number">0</span>.<span class="number">000004</span> | </div><div class="line">| init                           | <span class="number">0</span>.<span class="number">000002</span> | </div><div class="line">| <span class="type">Opening</span> tables                 | <span class="number">0</span>.<span class="number">000034</span> | </div><div class="line">| setup                          | <span class="number">0</span>.<span class="number">000035</span> | </div><div class="line">| creating table                 | <span class="number">0</span>.<span class="number">000558</span> | </div><div class="line">| <span class="type">After</span> create                   | <span class="number">0</span>.<span class="number">000020</span> | </div><div class="line">| <span class="type">System</span> lock                    | <span class="number">0</span>.<span class="number">002289</span> | </div><div class="line">| copy to tmp table              | <span class="number">1</span>.<span class="number">039543</span> | </div><div class="line">| rename <span class="literal">result</span> table            | <span class="number">0</span>.<span class="number">000017</span> | </div><div class="line">| <span class="type">Waiting</span> <span class="keyword">for</span> table metadata loc | <span class="number">1</span>.<span class="number">002122</span> | </div><div class="line">| rename <span class="literal">result</span> table            | <span class="number">0</span>.<span class="number">000012</span> | </div><div class="line">| <span class="type">Waiting</span> <span class="keyword">for</span> table metadata loc | <span class="number">1</span>.<span class="number">001946</span> | </div><div class="line">| rename <span class="literal">result</span> table            | <span class="number">0</span>.<span class="number">000009</span> | </div><div class="line">| <span class="type">Waiting</span> <span class="keyword">for</span> table metadata loc | <span class="number">1</span>.<span class="number">001933</span> | </div><div class="line">| rename <span class="literal">result</span> table            | <span class="number">0</span>.<span class="number">000008</span> | </div><div class="line">| <span class="type">Waiting</span> <span class="keyword">for</span> table metadata loc | <span class="number">1</span>.<span class="number">001938</span> | </div><div class="line">| rename <span class="literal">result</span> table            | <span class="number">0</span>.<span class="number">000009</span> | </div><div class="line">| <span class="type">Waiting</span> <span class="keyword">for</span> table metadata loc | <span class="number">1</span>.<span class="number">001964</span> | </div><div class="line">| rename <span class="literal">result</span> table            | <span class="number">0</span>.<span class="number">000009</span> | </div><div class="line">| <span class="type">Waiting</span> <span class="keyword">for</span> table metadata loc | <span class="number">0</span>.<span class="number">586454</span> | </div><div class="line">| rename <span class="literal">result</span> table            | <span class="number">0</span>.<span class="number">003639</span> | </div><div class="line">| <span class="keyword">end</span>                            | <span class="number">0</span>.<span class="number">000019</span> | </div><div class="line">| query <span class="keyword">end</span>                      | <span class="number">0</span>.<span class="number">000135</span> | </div><div class="line">| closing tables                 | <span class="number">0</span>.<span class="number">000018</span> | </div><div class="line">| freeing items                  | <span class="number">0</span>.<span class="number">000019</span> | </div><div class="line">| cleaning up                    | <span class="number">0</span>.<span class="number">000028</span> | </div><div class="line">+--------------------------------+----------+</div><div class="line"><span class="number">28</span> rows <span class="keyword">in</span> <span class="type">set</span>, <span class="number">1</span> warning (<span class="number">0</span>.<span class="number">00</span> sec)</div></pre></td></tr></table></figure>

<p>果然”copy to tmp table”出现了，这次再MySQL 5.6.21版本的实验结果就跟之前在问题三的MySQL 5.5.28版本的实验结果是一致的了（上面profile的结果是一张1w行的小表，2000w的大表执行一次ddl等待时间太长了…）。</p>
<h2 id="结论重复">结论重复</h2>
<ol>
<li>在MySQL 5.5.3以后的版本中，未提交的事务一定会堵塞DDL请求（据说5.6.6以后的版本做了相关的优化，未做测试暂且不提）</li>
<li>DDL在等待metada lock的过程中肯定会堵塞后续的DML请求，也有可能堵塞后续的SELECT请求（需要看SELECT请求是否能够命中qcache）</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天MySQL过载保护又立功干掉了一堆堵塞的SQL，到后台一看，发现了一大堆熟悉的”Waiting for table metadata lock”。之前刚好写过一篇关于metadata lock相关问题处理的<a href="http://hidba.ga/2014/09]]>
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL案例]之备份与Waiting for table flush]]></title>
    <link href="http://hidba.ga/2014/11/20/mysql-waiting-for-table-flush/"/>
    <id>http://hidba.ga/2014/11/20/mysql-waiting-for-table-flush/</id>
    <published>2014-11-20T10:16:41.000Z</published>
    <updated>2014-11-20T14:51:43.000Z</updated>
    <content type="html"><![CDATA[<p>今天在处理慢查询平台的slow query时发现今天排在第一个的居然是一个简单的SQL，运行了4166次，最长耗时610秒，长期处于“Waiting for table flush”状态。</p>
<p><img src="http://image-myrock-github-io.qiniudn.com/sql-20141120.jpg" alt=""></p>
<h2 id="结果说在前面">结果说在前面</h2>
<p>排查一番后果然不出意外：<strong>一个慢查询堵塞数据库备份进程，备份进程堵塞了后续的查询SQL，最后导致后续的大面积SQL等待。</strong></p>
<h2 id="那么问题来了">那么问题来了</h2>
<ol>
<li>一个慢查询是怎么堵塞mysqldump进程</li>
<li>mysqldump是怎么堵塞后续的查询请求</li>
</ol>
<a id="more"></a>

<p>首先我们来看下“Waiting for table flush”的解释</p>
<blockquote>
<p>Waiting for table：<br>Waiting for tables, Waiting for table, Waiting for table flush<br>The thread got a notification that the underlying structure for a table has changed and it needs to reopen the table to get the new structure. However, to reopen the table, it must wait until all other threads have closed the table in question.<br>This notification takes place if another thread has used FLUSH TABLES or one of the following statements on the table in question: FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, or OPTIMIZE TABLE.<br>In MySQL 5.5.6, Waiting for table was replaced with Waiting for table flush.</p>
</blockquote>
<p>看到手册的说明是不是能想到点什么？如果不行我们模拟下案发时的场景或许就明白了。</p>
<h2 id="场景重现">场景重现</h2>
<p>session A //模拟一个慢查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(*) from t_user_log a left join t_user b on a.uid = b.id;</div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>session B //启动一个备份进程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">shell</span>&gt; <span class="comment">mysqldump</span> <span class="literal">-</span><span class="comment">q</span> <span class="literal">-</span><span class="comment">Q</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">flush</span><span class="literal">-</span><span class="comment">logs</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">force</span> <span class="literal">-</span><span class="comment">R</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">opt</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">single</span><span class="literal">-</span><span class="comment">transaction</span> <span class="literal">-</span><span class="comment">S</span> <span class="string">.</span><span class="comment">/mysql</span><span class="string">.</span><span class="comment">sock</span> <span class="comment">dbname</span> &gt; <span class="string">.</span><span class="comment">/dbname</span><span class="string">.</span><span class="comment">sql</span></div></pre></td></tr></table></figure>

<p>session C //模拟一个简单的查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_user_log where id = <span class="number">1</span>;</div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>session D //查看进程状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show processlist;</span></div><div class="line">+------+------+-----------+--------------+---------+------+-------------------------+----------------------------------------------------------------------+-----------+---------------+-----------+</div><div class="line"><span class="header">| Id   | User | Host      | db           | Command | Time | State                   | Info                                                                 | Rows_sent | Rows_examined | Rows_read |</span></div><div class="line">+------+------+-----------+--------------+---------+------+-------------------------+----------------------------------------------------------------------+-----------+---------------+-----------+</div><div class="line">| 1405 | root | localhost | join<span class="emphasis">_test_</span>db | Query   |    7 | Sending data            | select count(<span class="strong">*) from t_user_log a left join t_user b on a.uid = b.id |         0 |             0 |         1 | </span></div><div class="line">| 1406 | root | localhost | join_test_db | Query   |    2 | Waiting for table flush | select * from t<span class="emphasis">_user_</span>log where id = 1                                |         0 |             0 |         1 | </div><div class="line">| 1408 | root | localhost | join<span class="emphasis">_test_</span>db | Query   |    0 | NULL                    | show processlist                                                     |         0 |             0 |         5 | </div><div class="line"><span class="header">| 1413 | root | localhost | NULL         | Query   |    5 | Waiting for table flush | FLUSH TABLES                                                         |         0 |             0 |         1 | </span></div><div class="line">+------+------+-----------+--------------+---------+------+-------------------------+----------------------------------------------------------------------+-----------+---------------+-----------+</div><div class="line">4 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>从上面的实验中我们可以看到一个慢查询堵塞了FLUSH TABLES的请求，FLUSH TABLES堵塞了后面的select请求。OK，回归到第一个问题。</p>
<h2 id="一个慢查询是怎么堵塞mysqldump的备份">一个慢查询是怎么堵塞mysqldump的备份</h2>
<p>我们的备份参数是<strong><em>-q -Q —flush-logs —force -R —opt —single-transaction</em></strong>，其中<strong><em>—flush-logs</em></strong>与<strong><em>—single-transaction</em></strong>两个参数放在一起会在开始dump数据之前先执行一个FLUSH TABLES操作，而FLUSH TABLES会关闭所有已经打开的表，所以会等待之前的请求执行结束，于是一个慢查询就这么堵塞了mysqldump进程。书面化的语言来描述就是：FLUSH TABLES正在等待成功获得锁，所以它必须等待其他事物其他锁的释放。</p>
<blockquote>
<p>FLUSH TABLES的效果是：关闭所有打开的表，同时清空query cache的内容。</p>
</blockquote>
<p>备份时general日志的记录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">141120 18:07:11  1458 Connect   root@localhost on</div><div class="line">                 1458 Query     <span class="operator"><span class="keyword">SELECT</span> SQL_NO_FCACHE <span class="keyword">NOW</span>()</span></div><div class="line">                 <span class="number">1458</span> <span class="keyword">Query</span>     <span class="comment">/*!40100 SET @@SQL_MODE='' */</span></div><div class="line">                 <span class="number">1458</span> <span class="keyword">Query</span>     <span class="comment">/*!40103 SET TIME_ZONE='+00:00' */</span></div><div class="line">                 <span class="number">1458</span> <span class="keyword">Query</span>     <span class="keyword">FLUSH</span> <span class="keyword">TABLES</span></div><div class="line">                 <span class="number">1458</span> <span class="keyword">Query</span>     <span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span></div><div class="line">                 <span class="number">1458</span> Refresh</div></pre></td></tr></table></figure>

<h2 id="mysqldump是怎么堵塞后续的查询请求">mysqldump是怎么堵塞后续的查询请求</h2>
<p>我们说到按上面描述的参数执行mysqldump时会首先执行一个FLUSH TABLES的命令，在FLUSH TABLES等待加锁成功的过程中会导致后续的请求也在排队等待获得锁，类似一个排他锁的效果。因此后续执行的SQL也在等待中，这就是文章开头我们描述的问题产生的全过程，</p>
<blockquote>
<p>it must wait until all other threads have closed the table in question.</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>最后总结下，很多时候我们会把后台统计的SQL或者备份进程放在半夜负载最低的时候运行，但是这往往就容易造成上面我们描述的一系列问题，严重的时候可能导致系统瘫痪，所以各位DBA同学需要合理的管理规划好自己数据库的<strong>统计以及备份的作业计划</strong>。</p>
<h2 id="其余说明">其余说明</h2>
<p>mysqldump除了<strong><em>—flush-logs</em></strong>与<strong><em>—single-transaction</em></strong>两个参数放在一起会导致这样的问题以外，<strong><em>—lock-all-tables</em></strong>以及<strong><em>—master-data</em></strong>两个参数同样也会引发这个问题。</p>
<h2 id="遗留问题">遗留问题</h2>
<p>mysqldump进程单独使用<strong><em>—flush-logs</em></strong>与<strong><em>—single-transaction</em></strong>两个参数其中一个时都不会执行FLUSH TABLES，为什么放在一起就会呢？<br>一个是刷新二进制日志，一个是通过设置事务隔离级别达到获取InnoDB表一致性快照的效果，两个加在一起为什么会需要执行FLUSH TABLES呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天在处理慢查询平台的slow query时发现今天排在第一个的居然是一个简单的SQL，运行了4166次，最长耗时610秒，长期处于“Waiting for table flush”状态。</p>
<p><img src="http://image-myrock-github-io.qiniudn.com/sql-20141120.jpg" alt=""></p>
<h2 id="结果说在前面">结果说在前面</h2>
<p>排查一番后果然不出意外：<strong>一个慢查询堵塞数据库备份进程，备份进程堵塞了后续的查询SQL，最后导致后续的大面积SQL等待。</strong></p>
<h2 id="那么问题来了">那么问题来了</h2>
<ol>
<li>一个慢查询是怎么堵塞mysqldump进程</li>
<li>mysqldump是怎么堵塞后续的查询请求</li>
</ol>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis运维经验一二三]]></title>
    <link href="http://hidba.ga/2014/11/07/redis-ops/"/>
    <id>http://hidba.ga/2014/11/07/redis-ops/</id>
    <published>2014-11-07T09:07:15.000Z</published>
    <updated>2014-11-10T08:28:11.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍一些列简单的redis运维经验，帮助大家对redis的运维有个初步的了解，条目不分先后，后续还会持续添加。本文档预期读者为：redis使用者。</p>
<h2 id="计算延迟时间">计算延迟时间</h2>
<p>这里的延迟时间指的是指令请求的等待时间（单位为毫秒），包含网络延时以及单线程的命令等待，命令很简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">redis-cli --latency- history --i &lt;interval&gt;</span> -h `host` -p `port`</span></div></pre></td></tr></table></figure>

<p>这里我们来测试下<br><strong>场景1：本地空闲的redis实例，延时几乎为0</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@lxj tmp]<span class="preprocessor"># /usr/local/redis/bin/redis-cli --latency-history -i 5 -h 10.59.xx.xx -p 6379</span></div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">1</span>, avg: <span class="number">0.00</span> (<span class="number">455</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">0</span>, avg: <span class="number">0.00</span> (<span class="number">423</span> samples) -- <span class="number">5.00</span> seconds range</div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">1</span>, avg: <span class="number">0.00</span> (<span class="number">455</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">1</span>, avg: <span class="number">0.28</span> (<span class="number">455</span> samples) -- <span class="number">5.01</span> seconds range</div></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>场景2：模拟网络延时严重的场景（client），由于客户端出口带宽被打满，导致请求延时，平均在30毫秒+</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@lxj</span> ~]# /usr/local/redis/bin/redis-cli --latency-history -i <span class="number">5</span> -h <span class="number">10.59</span>.xx.xx -p <span class="number">20010</span> -a <span class="string">'xxxxx'</span></div><div class="line"><span class="keyword">min</span>: <span class="number">9</span>, <span class="keyword">max</span>: <span class="number">640</span>, avg: <span class="number">48.21</span> (<span class="number">87</span> samples) -- <span class="number">5.17</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">9</span>, <span class="keyword">max</span>: <span class="number">639</span>, avg: <span class="number">38.48</span> (<span class="number">101</span> samples) -- <span class="number">5.02</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">9</span>, <span class="keyword">max</span>: <span class="number">1472</span>, avg: <span class="number">54.92</span> (<span class="number">78</span> samples) -- <span class="number">5.14</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">9</span>, <span class="keyword">max</span>: <span class="number">219</span>, avg: <span class="number">26.30</span> (<span class="number">135</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">9</span>, <span class="keyword">max</span>: <span class="number">637</span>, avg: <span class="number">30.42</span> (<span class="number">119</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">9</span>, <span class="keyword">max</span>: <span class="number">639</span>, avg: <span class="number">21.83</span> (<span class="number">150</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">9</span>, <span class="keyword">max</span>: <span class="number">636</span>, avg: <span class="number">45.84</span> (<span class="number">91</span> samples) -- <span class="number">5.20</span> seconds range</div></pre></td></tr></table></figure>

<p><strong>场景3：生产redis实例1，该实例平均延时较高，很多时候平均延时几乎到1毫秒，最大延时到了13毫秒，这样的请求跟负载注定实例的qps以及吞吐量不会高</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@lxj</span> ~]# /usr/local/redis/bin/redis-cli --latency-history -i <span class="number">5</span> -h <span class="number">10.59</span>.xx.xx -p <span class="number">20010</span> -a <span class="string">'xxxxx'</span></div><div class="line"><span class="keyword">min</span>: <span class="number">1</span>, <span class="keyword">max</span>: <span class="number">2</span>, avg: <span class="number">1.03</span> (<span class="number">453</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">1</span>, avg: <span class="number">1.00</span> (<span class="number">445</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">1</span>, avg: <span class="number">0.98</span> (<span class="number">417</span> samples) -- <span class="number">5.00</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">2</span>, avg: <span class="number">0.96</span> (<span class="number">422</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">13</span>, avg: <span class="number">0.81</span> (<span class="number">448</span> samples) -- <span class="number">5.00</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">2</span>, avg: <span class="number">0.49</span> (<span class="number">447</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">2</span>, avg: <span class="number">0.17</span> (<span class="number">418</span> samples) -- <span class="number">5.00</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">1</span>, avg: <span class="number">0.12</span> (<span class="number">418</span> samples) -- <span class="number">5.01</span> seconds range</div></pre></td></tr></table></figure>

<p><strong>场景4：生产redis实例2，该实例比起实例1平均延时较低，平均延时在0.01~0.13毫秒，算是比较健康的实例</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@lxj</span> tmp]# /usr/local/redis/bin/redis-cli --latency-history -i <span class="number">5</span> -h <span class="number">10.59</span>.xx.xx -p <span class="number">6379</span> -a <span class="string">'xxxx'</span></div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">2</span>, avg: <span class="number">0.13</span> (<span class="number">418</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">1</span>, avg: <span class="number">0.03</span> (<span class="number">443</span> samples) -- <span class="number">5.00</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">1</span>, avg: <span class="number">0.01</span> (<span class="number">454</span> samples) -- <span class="number">5.00</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">1</span>, avg: <span class="number">0.01</span> (<span class="number">447</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="keyword">min</span>: <span class="number">0</span>, <span class="keyword">max</span>: <span class="number">1</span>, avg: <span class="number">0.00</span> (<span class="number">418</span> samples) -- <span class="number">5.01</span> seconds range</div></pre></td></tr></table></figure>

<h2 id="注意产生的流量">注意产生的流量</h2>
<p>很多时候我们也需要注意下redis服务器的流量负载情况，由于redis本身的高性能服务，我们的生产服务就出现过直接把服务器出口带宽打满的现象。这点只需要注意下即可，正常出现概率不高。</p>
<h2 id="注意请求的时间复杂度">注意请求的时间复杂度</h2>
<p>时间复杂度是指redis指令执行的时间复杂度，从O(1)到O(N)甚至更复杂不等。我们建议将一些复杂度O(N)甚至是更复杂的操作，比如：排序，多键操作等等指令转化或者是放在redis slave上，达到效率提升的目的，说白了有点读写分离的意思。</p>
<blockquote>
<p>案例1：某项目推送模块的redis优化，其中有一个是：将复杂度为O(log(N)+M)的ZREVRANGE操作转换为list的O(1)操作，qps从5000上升到6500。</p>
<p>案例2：某项目的一个在线用户统计模块，包含了大量的keys的遍历操作（大约6%的请求占了90%+的请求时间），导致redis吞吐大大降低，取消掉keys操作以后，吞吐量开始回升。</p>
</blockquote>
<p>而这些信息我们可以通过一个redis-faina.py的脚本或获取redis的运行状态以及信息，从中我们可以发现一些优化点，具体信息见下。</p>
<p><strong><em>注意事项1：该脚本运行环境为python2.7，当监控redis2.4的实例时需要加上—redis-version=2.4的参数。</em></strong><br><strong><em>注意事项2：该脚本的的执行统计时长不是绝对准确，在繁忙的环境下可以作为参考，在限时数据不尽准确（执行时长是以两个指令开始执行的时间差作为第一个指令执行的时长，其中可能包含空闲等待的时间）。</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">[root@lxj tmp]# redis-cli -h 10.59.xx.xx -p 20010 -a <span class="emphasis">'xxxxx'</span> MONITOR |head -n 10000 | python redis-faina.py  // -n 10000是取样10000次请求的意思        </div><div class="line"><span class="header">Overall Stats</span></div><div class="line">========================================</div><div class="line">Lines Processed         10000</div><div class="line"><span class="header">Commands/Sec            2125.30 //QPS一个很重要的性能指标</span></div><div class="line">--------------------------------------------------------------------</div><div class="line"><span class="header">Top Prefixes</span></div><div class="line">========================================</div><div class="line"><span class="header">push    8067    (80.67%)</span></div><div class="line">--------------------------------------------------------------------</div><div class="line"><span class="header">Top Keys //请求最多的KEY</span></div><div class="line">========================================</div><div class="line">4474d2d3406340ccb39e4cb7103f5a79        1932    (19.32%)</div><div class="line">push:onlinedevice:3:1                   1930    (19.30%)</div><div class="line">push:messagelist:android:3              1620    (16.20%)</div><div class="line">push:onlineuser:3:1                     321     (3.21%)</div><div class="line">push:user:3:1:166457                    4       (0.04%)</div><div class="line">push:user:3:1:69651                     4       (0.04%)</div><div class="line">push:user:3:1:145696                    4       (0.04%)</div><div class="line"><span class="header">push:user:3:1:188873                    4       (0.04%)</span></div><div class="line">--------------------------------------------------------------------</div><div class="line"><span class="header">Top Commands //请求最多的指令</span></div><div class="line">========================================</div><div class="line">ZADD            2252    (22.52%)</div><div class="line">AUTH            1932    (19.32%)</div><div class="line">SETEX           1930    (19.30%)</div><div class="line">LPOP            1621    (16.21%)</div><div class="line">LRANGE          1620    (16.20%)</div><div class="line">SADD            321     (3.21%)</div><div class="line">EXPIRE          321     (3.21%)</div><div class="line"><span class="header">SET             2       (0.02%)</span></div><div class="line">--------------------------------------------------------------------</div><div class="line"><span class="header">Command Time (microsecs) //响应时间的正态分布</span></div><div class="line">========================================</div><div class="line">Median          167.75</div><div class="line">75%             349.75</div><div class="line">90%             1109.0</div><div class="line"><span class="header">99%             5474.25</span></div><div class="line">--------------------------------------------------------------------</div><div class="line"><span class="header">Heaviest Commands (microsecs) //指令的总体耗时</span></div><div class="line">========================================</div><div class="line">LRANGE          2370628.25</div><div class="line">SETEX           1413046.0</div><div class="line">AUTH            472047.75</div><div class="line">LPOP            281701.75</div><div class="line">ZADD            153476.25</div><div class="line">SADD            7956.75</div><div class="line">EXPIRE          5963.75</div><div class="line"><span class="header">SET             388.5</span></div><div class="line">--------------------------------------------------------------------</div><div class="line"><span class="header">Slowest Calls //慢查询</span></div><div class="line">========================================</div><div class="line">17460.25        "LRANGE" "push:messagelist:android:3" "0" "-1"</div><div class="line">16738.25        "SETEX" "push:detail:3:1:be461ce1a982c30771b0fa90496fd492" "1800" "a:2:{s:6:\"app<span class="emphasis">_id\";i:3;s:11:\"device_</span>type\";s:1:\"1\";}"</div><div class="line">16026.0         "LRANGE" "push:messagelist:android:3" "0" "-1"</div><div class="line">15986.0         "LRANGE" "push:messagelist:android:3" "0" "-1"</div><div class="line">15124.0         "LRANGE" "push:messagelist:android:3" "0" "-1"</div><div class="line">14983.75        "LRANGE" "push:messagelist:android:3" "0" "-1"</div><div class="line">13885.0         "LRANGE" "push:messagelist:android:3" "0" "-1"</div><div class="line">13792.0         "LRANGE" "push:messagelist:android:3" "0" "-1"</div></pre></td></tr></table></figure>

<h2 id="不必要的操作">不必要的操作</h2>
<p>不需要的操作是指类型一些EXISTS、DEL这样的操作，在很多场景下是完全没有必要的，在QPS不变的情况下，取消这些不必要的请求可以达到提升有效用户请求的数量。</p>
<blockquote>
<p>案例1：XX项目点播业务的redis实例，平均约存在37.34%的EXISTS请求，而EXISTS是用在每次对key做操作(GET,ZRANGE ,HMGET…)前都执行，用于判断该key是否存在，其实redis这些api对于不存在的key都会返回提示，因此可以直接取消EXISTS的请求，在QPS不变的情况下，有效用户请求可以提升约37.34%。</p>
<p>案例2：XX项目推送业务的redis实例中存在25.5%的DEL操作，占据约40%的请求时间，后将key直接设置过期时间，在同样的QPS下，用户有效请求得到提升。</p>
</blockquote>
<p>但是并不代表EXISTS、DEL这类型的操作都是不必要的请求，具体案例还需具体分析，存在必有其道理。</p>
<h2 id="管道操作">管道操作</h2>
<p>Redis提供一个pipeline的管道操作模式，将多个指令汇总到队列中批量执行，可以减少tcp交互产生的时间，一般情况下能够有10%~30%不等的性能提升。<br>但是需要注意的是，pipeline与multi不同，无法保证请求之间的原子性，因此需要考虑使用场景。如果业务场景允许，这也是一个性能提升的点。</p>
<h2 id="IO优化">IO优化</h2>
<p>IO优化主要是redis快照或者aof产生的，一般我们需要根据redis中上数据的重要程度来设置快照频率，或者是快照只在slave上发生。</p>
<h2 id="注意CPU使用率">注意CPU使用率</h2>
<p>Redis是单线程作业，因此需要注意CPU使用率，除了分离业务，读写分离以外，twemproxy也能有效的提升redis的CPU利用率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍一些列简单的redis运维经验，帮助大家对redis的运维有个初步的了解，条目不分先后，后续还会持续添加。本文档预期读者为：redis使用者。</p>
<h2 id="计算延迟时间">计算延迟时间</h2>
<p>这里的延迟时间指的是指令请求的等待时间（单位为毫秒），包含网络延时以及单线程的命令等待，命令很简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">redis-cli --latency- history --i &lt;interval&gt;</span> -h `host` -p `port`</span></div></pre></td></tr></table></figure>

<p>这里我们来测试下<br><strong>场景1：本地空闲的redis实例，延时几乎为0</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@lxj tmp]<span class="preprocessor"># /usr/local/redis/bin/redis-cli --latency-history -i 5 -h 10.59.xx.xx -p 6379</span></div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">1</span>, avg: <span class="number">0.00</span> (<span class="number">455</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">0</span>, avg: <span class="number">0.00</span> (<span class="number">423</span> samples) -- <span class="number">5.00</span> seconds range</div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">1</span>, avg: <span class="number">0.00</span> (<span class="number">455</span> samples) -- <span class="number">5.01</span> seconds range</div><div class="line"><span class="built_in">min</span>: <span class="number">0</span>, <span class="built_in">max</span>: <span class="number">1</span>, avg: <span class="number">0.28</span> (<span class="number">455</span> samples) -- <span class="number">5.01</span> seconds range</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="NoSQL" scheme="http://hidba.ga/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://hidba.ga/tags/Redis/"/>
    
      <category term="ops" scheme="http://hidba.ga/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL SQL优化系列]之如何高效获取随机数据]]></title>
    <link href="http://hidba.ga/2014/10/29/rand-query/"/>
    <id>http://hidba.ga/2014/10/29/rand-query/</id>
    <published>2014-10-29T08:52:02.000Z</published>
    <updated>2014-11-07T07:04:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>前几天有位同事问我MySQL要怎么返回一张表的几行随机数据。这个问题其实网上随便一搜答案一大把，但是效果都不太理想，当你要获取随机几行（不是1行）时，得到的数据不是全随机的，而是随机区域。那么有没有办法真正的返回全随机的数据呢？</p>
<h2 id="分析">分析</h2>
<p>一般来说获取随机数据，我们第一时间想到的应该是rand()函数。最直接的是order by rand() limit n，这完全能够符合我们的需求，但是效率之地令人发指。我们来看看手册里面是怎么对这个函数描述的：</p>
<blockquote>
<p>Returns a random floating-point value v in the range 0 &lt;= v &lt; 1.0.<br>…<br>You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times.<br>…<br>RAND() is not meant to be a perfect random generator. It is a fast way to generate random numbers on demand that is portable between platforms for the same MySQL version.</p>
</blockquote>
<p>简单说rand()能够随机返回一个从0~1之间的值，直接使用order by rand() limit m可以在表里获取随机样本，但是也会导致order by重复计算，因此效率非常低下，我们看一个例子。</p>
<a id="more"></a>

<h2 id="方案1">方案1</h2>
<p><strong><em>test 1-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select id from t_user order by rand() limit 10; </span></div><div class="line">+--------+</div><div class="line"><span class="header">| id     |</span></div><div class="line">+--------+</div><div class="line">|  96979 | </div><div class="line">|  82638 | </div><div class="line">| 115767 | </div><div class="line">| 110451 | </div><div class="line">|  47689 | </div><div class="line">| 120664 | </div><div class="line">| 110043 | </div><div class="line">|  75426 | </div><div class="line">|  35199 | </div><div class="line"><span class="header">| 120880 | </span></div><div class="line">+--------+</div><div class="line">10 rows in set (0.12 sec)</div></pre></td></tr></table></figure>

<p>上面案例中的表有10w行，在高并发的场景中已经已经是几乎完全不能接受，要是更大的表比如100w1000w呢？按照我们一贯贯彻的SQL优化思路来思考，是不是我得出m个随机值然后直接通过主键自增ID来比较即可（<strong>所有测试都是建立在表存在自增ID主键的前提下</strong>）？</p>
<p><strong><em>test 1-2</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select id from t_user_log where id &gt; (select max(id) from t_user) * rand() limit 10;</span></div><div class="line">+------+</div><div class="line"><span class="header">| id   |</span></div><div class="line">+------+</div><div class="line">|  421 | </div><div class="line">|  478 | </div><div class="line">|  514 | </div><div class="line">|  772 | </div><div class="line">| 1070 | </div><div class="line">| 1152 | </div><div class="line">| 1230 | </div><div class="line">| 1452 | </div><div class="line">| 1501 | </div><div class="line"><span class="header">| 1504 | </span></div><div class="line">+------+</div><div class="line">10 rows in set (0.00 sec)</div><div class="line"><span class="comment">// 注：t_user_log表约3000万行数据</span></div></pre></td></tr></table></figure>

<p>OK，非常高效，也是全部随机数据。但是注意到没有，返回的数据都是非常小，几乎都在表的最前面的一部分数据。<strong>那是因为limit 10的缘故，limit 10会直接在结果集做顺序匹配，一直到返回足够数量（10）的数据就结束查询。</strong>而rand()的值在每次递归查询时都是变化的，因此的出来值得几乎都是靠表的最前面部分，而得不到真正意思上的随机样本。这里我们可以explain验证下，是否走全表扫描/主键扫描/或者其他顺序跟主键排列一致的索引扫描。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; explain  select id from t_user_log  where id &gt; (select max(id) from t_user) * rand() limit 10;                   </span></div><div class="line">+----+-------------+------------+-------+---------------+-----------+---------+------+----------+------------------------------+</div><div class="line"><span class="header">| id | select_type | table      | type  | possible_keys | key       | key_len | ref  | rows     | Extra                        |</span></div><div class="line">+----+-------------+------------+-------+---------------+-----------+---------+------+----------+------------------------------+</div><div class="line">|  1 | PRIMARY     | t<span class="emphasis">_user_</span>log | index | NULL          | logintime | 4       | NULL | 29345201 | Using where; Using index     | </div><div class="line"><span class="header">|  2 | SUBQUERY    | NULL       | NULL  | NULL          | NULL      | NULL    | NULL |     NULL | Select tables optimized away | </span></div><div class="line">+----+-------------+------------+-------+---------------+-----------+---------+------+----------+------------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>如我们所料，查询是logintime索引扫描，而logintime是主键递增与自增ID主键的排列顺序是一致的。为了再彻底验证我们的想法，再做一个实验，分别强制使用主键以及另外的排列顺序与主键不一致的索引看看，返回数据区间是否发生了变化。</p>
<p><strong><em>test 1-3</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select id from t_user_log force index (primary) where id &gt; (select max(id) from t_user) * rand() limit 10;          </span></div><div class="line">+------+</div><div class="line"><span class="header">| id   |</span></div><div class="line">+------+</div><div class="line">|  288 | </div><div class="line">|  928 | </div><div class="line">| 1689 | </div><div class="line">| 1692 | </div><div class="line">| 1745 | </div><div class="line">| 1753 | </div><div class="line">| 1761 | </div><div class="line">| 1823 | </div><div class="line">| 1921 | </div><div class="line"><span class="header">| 1923 | </span></div><div class="line">+------+</div><div class="line">10 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select id from t_user_log force index (loginip) where id &gt; (select max(id) from t_user) * rand() limit 10;       </span></div><div class="line">+----------+</div><div class="line"><span class="header">| id       |</span></div><div class="line">+----------+</div><div class="line">| 25142689 | </div><div class="line">| 25680519 | </div><div class="line">| 17320096 | </div><div class="line">| 23015757 | </div><div class="line">|  8516312 | </div><div class="line">| 28329444 | </div><div class="line">| 28327037 | </div><div class="line">|  2838989 | </div><div class="line">|  9054950 | </div><div class="line"><span class="header">| 14630833 | </span></div><div class="line">+----------+</div><div class="line">10 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>测试证明了我们的想法是正确的，走主键依然跟之前走logintime一样都是返回表前面部分的数据，换了一个排列顺序与主键不一致的loginip作为索引，返回的结果看起来就比较随机化。这里也证明我们的第一种SQL改造达不到理想的效果，这与优化器对索引的选择有关。</p>
<h2 id="方案2">方案2</h2>
<p>这里我们使用网上流传比较广泛的关联写法来看看能否达到我们的预期。</p>
<p><strong><em>test 2-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select a.id from  t<span class="emphasis">_user_</span>log a join (select rand() * (select max(id) from t<span class="emphasis">_user_</span>log ) as rid) b </div><div class="line"><span class="header">    -&gt; on a.id &gt; b.rid limit 10;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| id       |</span></div><div class="line">+----------+</div><div class="line">| 23702733 | </div><div class="line">| 23702734 | </div><div class="line">| 23702735 | </div><div class="line">| 23702736 | </div><div class="line">| 23702737 | </div><div class="line">| 23702738 | </div><div class="line">| 23702739 | </div><div class="line">| 23702740 | </div><div class="line">| 23702741 | </div><div class="line"><span class="header">| 23702742 | </span></div><div class="line">+----------+</div><div class="line">10 rows in set (0.01 sec)</div></pre></td></tr></table></figure>

<p>效率很高，但是返回的数据其实是随机区间，而不是真正的随机几条样本。也就是说你要获取的是随机一行那OK，要是随机几行或许还达不到真正的需求。<br>前面我们也说了rand()在where中，每行计算都会重新计算也就是说它是一个变量，但是在上面的例子中，rand()出现在匹配表中，而不是后面的过滤条件，因此只会产生一个值，可以近似理解为一个常量，最后在这个常量只是做过滤匹配，选择10行数据因此，得到的是一个随机区间的数据。</p>
<h2 id="方案3">方案3</h2>
<p>我们的需求是得到完全随机的N行数据，那么换个思路，我们能不能得到N个小于最大ID的随机数据数字ID，再使用主键匹配关联呢？MayBe.</p>
<p><strong><em>test 3-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select (select max(id) from t_user_log) * rand() from t_user_log limit 10;</span></div><div class="line">+-------------------------------------------+</div><div class="line"><span class="header">| (select max(id) from t_user_log) * rand() |</span></div><div class="line">+-------------------------------------------+</div><div class="line">|                        18017949.208536115 | </div><div class="line">|                         792399.6698163977 | </div><div class="line">|                        11028577.662700385 | </div><div class="line">|                         22205477.24327947 | </div><div class="line">|                        16821228.167522915 | </div><div class="line">|                        17489710.047002923 | </div><div class="line">|                         6424653.671672591 | </div><div class="line">|                        10214352.156580932 | </div><div class="line">|                        1237587.7071136252 | </div><div class="line"><span class="header">|                        6105096.0050520655 | </span></div><div class="line">+-------------------------------------------+</div><div class="line">10 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select a.id from t<span class="emphasis">_user_</span>log a join (select round((select max(id) from t<span class="emphasis">_user_</span>log) * rand())  as rid </div><div class="line"><span class="header">    -&gt; from t_user_log limit 10) b where a.id = b.rid;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| id       |</span></div><div class="line">+----------+</div><div class="line">| 22648946 | </div><div class="line">| 25595789 | </div><div class="line">| 29471892 | </div><div class="line">|  9451671 | </div><div class="line">| 19963103 | </div><div class="line">| 10340078 | </div><div class="line">| 22371296 | </div><div class="line">| 19715821 | </div><div class="line">|   905005 | </div><div class="line"><span class="header">|  6497987 | </span></div><div class="line">+----------+</div><div class="line">10 rows in set (0.05 sec)</div></pre></td></tr></table></figure>

<p>OK，到这里是不是就能完美的解决我们的问题呢。从3000W行的大表中真正的随机返回10行数据数据就是这么简单。如果你更处女座一点，又或者你的表数据被截断过min(id)可能都非常大，那么我们可以再彻底点。</p>
<p><strong><em>test 3-2</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="code"> mysql&gt; select a.id from  t_user_log a join </span></div><div class="line"><span class="code">     -&gt; (select round(( select max(id) - min(id) from t_user_log ) * rand() + (select min(id) from t_user_log))  as rid from t_user_log limit 10 ) </span></div><div class="line"><span class="header">     -&gt; b on a.id = b.rid ;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| id       |</span></div><div class="line">+----------+</div><div class="line">| 15740358 | </div><div class="line">| 28635240 | </div><div class="line">|  4274489 | </div><div class="line">| 27147362 | </div><div class="line">|   672493 | </div><div class="line">| 13601017 | </div><div class="line">|  4867180 | </div><div class="line">| 14093062 | </div><div class="line">| 25303557 | </div><div class="line"><span class="header">| 23118176 | </span></div><div class="line">+----------+</div><div class="line">10 rows in set (0.03 sec)</div></pre></td></tr></table></figure>

<p><strong>不过如果你表中间删除的数据太多（数据空洞大），使用这种方式可能会造成最终返回的数据小于指定的行数（感谢金荣同学的提醒）。</strong></p>
<h2 id="总结">总结</h2>
<p>最后总结下：</p>
<ol>
<li>方案二的优点是即使存在数据空洞依然能够返回足够的数据，但也存在返回的数据是随机区间而不是真正随机样本的缺点</li>
<li>方案三的优点是能高效的返回真正随机样本数据，但是在存在数据空洞的情况下可能返回的数据量小于你的需求<br>因此大家还是根据自己的需求灵活选择那种才是最好的解决方案。</li>
</ol>
<h2 id="其他注意">其他注意</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bad : <span class="operator"><span class="keyword">select</span> <span class="keyword">max</span>(id) * <span class="keyword">rand</span>() <span class="keyword">from</span> t_user_log;</span></div><div class="line">good : <span class="operator"><span class="keyword">select</span> (<span class="keyword">select</span> <span class="keyword">max</span>(id) <span class="keyword">from</span> t_user_log) * <span class="keyword">rand</span>();</span></div></pre></td></tr></table></figure>

<p>上面两种写法的效果是一样的，但是代价却是天差地别，在一张表里面使用rand()计算跟与一个常量进行计算的效率差距是非常大的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="起因">起因</h2>
<p>前几天有位同事问我MySQL要怎么返回一张表的几行随机数据。这个问题其实网上随便一搜答案一大把，但是效果都不太理想，当你要获取随机几行（不是1行）时，得到的数据不是全随机的，而是随机区域。那么有没有办法真正的返回全随机的数据呢？</p>
<h2 id="分析">分析</h2>
<p>一般来说获取随机数据，我们第一时间想到的应该是rand()函数。最直接的是order by rand() limit n，这完全能够符合我们的需求，但是效率之地令人发指。我们来看看手册里面是怎么对这个函数描述的：</p>
<blockquote>
<p>Returns a random floating-point value v in the range 0 &lt;= v &lt; 1.0.<br>…<br>You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times.<br>…<br>RAND() is not meant to be a perfect random generator. It is a fast way to generate random numbers on demand that is portable between platforms for the same MySQL version.</p>
</blockquote>
<p>简单说rand()能够随机返回一个从0~1之间的值，直接使用order by rand() limit m可以在表里获取随机样本，但是也会导致order by重复计算，因此效率非常低下，我们看一个例子。</p>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
      <category term="SQL优化" scheme="http://hidba.ga/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL SQL优化系列]之分页查询]]></title>
    <link href="http://hidba.ga/2014/10/21/optimize-limit-query/"/>
    <id>http://hidba.ga/2014/10/21/optimize-limit-query/</id>
    <published>2014-10-21T07:01:17.000Z</published>
    <updated>2014-11-07T07:04:23.000Z</updated>
    <content type="html"><![CDATA[<p>记得在很久以前我在公司内部做过一次MySQL优化分享里面说到一个使用延迟关联实现排序分页类型SQL的优化，这个案例在《高性能MySQL》的第二版还是第三版也有提及。</p>
<blockquote>
<p>延迟关联：通过覆盖索引返回所需数据行的主键，再通过主键获取所需数据。</p>
</blockquote>
<p>这里我们来看一个使用延迟关联优化排序分页SQL的案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select sql_no_cache * from t_user_log where appname = '发号中心' order by logintime limit 1000000,1;</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| id      | uid       | username                 | appname      | loginip         | loginlocation                      | logintime  | logintype | useragent |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| 2246895 | 114790028 | xxxxxxxxxxxxxx@17173.com | 发号中心     | 220.172.xxx.xxx | 贵州省黔南州都匀市 电信            | 1407055334 |         1 |           |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line">1 row in set (2.05 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select sql_no_cache a.* from t_user_log a inner join (select id from t_user_log where appname = '发号中心' order by logintime limit 1000000,1) b on a.id = b.id; </span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| id      | uid       | username                 | appname      | loginip         | loginlocation                      | logintime  | logintype | useragent |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| 2246895 | 114790028 | xxxxxxxxxxxxxx@17173.com | 发号中心     | 220.172.xxx.xxx | 贵州省黔南州都匀市 电信            | 1407055334 |         1 |           |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line">1 row in set (0.87 sec)</div></pre></td></tr></table></figure>

<p>确实使用延迟关联以后SQL效率提升了约135%左右。</p>
<h2 id="那么问题来了">那么问题来了</h2>
<ol>
<li>延迟关联的用法在InnoDB跟MyISAM两种引擎上是否有区别？</li>
<li>延迟关联是否优化排序分页SQL的最优方法？</li>
</ol>
<a id="more"></a>

<h2 id="延迟关联的方法在InnoDB与MyISAM两种引擎的区别">延迟关联的方法在InnoDB与MyISAM两种引擎的区别</h2>
<p>上面我们说了什么是延迟关联，但是很明显跟InnoDB应该是没有关系的，所以大体来说是一样的，但是严格来说还是存在一点点小区别。区别在于覆盖索引的范围。因为InnoDB是主键聚合，所以任何二级索引的尾部都会加上pk，但是MyISAM就没有这个特性了，因此MyISAM如果需要使用延迟关联，那么覆盖索引的最后需要加上主键字段，否则效率会大打折扣。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select sql_no_cache * from log_201409 where lastloginchannel = '1018' limit 1000000,1; </span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| username                  | loginip      | logintime           | lastloginchannel | regtime             | id      |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| xxxxxxxxxxxxxxx@17173.com | 60.167.xx.xx | 2014-09-03 22:24:10 | 1018             | 0000-00-00 00:00:00 | 2353297 |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line">1 row in set (1.41 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select sql_no_cache a.* from log_201409 a inner join (select id from log_201409 where lastloginchannel = '1018' limit 1000000,1 ) b on a.id = b.id;        </span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| username                  | loginip      | logintime           | lastloginchannel | regtime             | id      |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| xxxxxxxxxxxxxxx@17173.com | 60.167.xx.xx | 2014-09-03 22:24:10 | 1018             | 0000-00-00 00:00:00 | 2353297 |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line">1 row in set (0.95 sec)</div><div class="line"><span class="comment">//覆盖索引包含主键</span></div><div class="line"></div><div class="line"><span class="header">mysql&gt; select sql_no_cache a.* from log_201409 a inner join (select id from log_201409 force index (i_lastloginchannel) where lastloginchannel = '1018' limit 1000000,1 ) b on a.id = b.id;        </span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| username                  | loginip      | logintime           | lastloginchannel | regtime             | id      |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| xxxxxxxxxxxxxxx@17173.com | 60.167.xx.xx | 2014-09-03 22:24:10 | 1018             | 0000-00-00 00:00:00 | 2353297 |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line">1 row in set (1.32 sec)</div><div class="line"><span class="comment">// 覆盖索引不包含主键</span></div></pre></td></tr></table></figure>

<h2 id="比延迟关联更好的解决方案">比延迟关联更好的解决方案</h2>
<p>延迟关联避免了不必要的数据页扫描，但是避免不了索引扫描，因此在limit m,n的m值很大的时候，优化效果还是不尽如人意的。这个我看下执行计划就知道了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select sql_no_cache * <span class="keyword">from</span> t_user_log a inner join (select id <span class="keyword">from</span> t_user_log where appname = '发号中心' order by logintime limit <span class="number">1000000</span>,<span class="number">1</span>) b on a.id = b.id;</div><div class="line">+----+-------------+------------+--------+-------------------------------+-----------------------+---------+-------+----------+--------------------------+</div><div class="line">| id | select_type | table      | <span class="keyword">type</span>   | possible_keys                 | key                   | key_len | <span class="keyword">ref</span>   | rows     | <span class="type">Extra</span>                    |</div><div class="line">+----+-------------+------------+--------+-------------------------------+-----------------------+---------+-------+----------+--------------------------+</div><div class="line">|  <span class="number">1</span> | <span class="type">PRIMARY</span>     | &lt;derived2&gt; | <span class="type">ALL</span>    | <span class="type">NULL</span>                          | <span class="type">NULL</span>                  | <span class="type">NULL</span>    | <span class="type">NULL</span>  |  <span class="number">1000001</span> | <span class="type">NULL</span>                     |</div><div class="line">|  <span class="number">1</span> | <span class="type">PRIMARY</span>     | a          | eq_ref | <span class="type">PRIMARY</span>                       | <span class="type">PRIMARY</span>               | <span class="number">4</span>       | b.id  |        <span class="number">1</span> | <span class="type">NULL</span>                     |</div><div class="line">|  <span class="number">2</span> | <span class="type">DERIVED</span>     | t_user_log | <span class="keyword">ref</span>    | appname,idx_appname_logintime | idx_appname_logintime | <span class="number">152</span>     | <span class="keyword">const</span> | <span class="number">14672600</span> | <span class="type">Using</span> where; <span class="type">Using</span> index |</div><div class="line">+----+-------------+------------+--------+-------------------------------+-----------------------+---------+-------+----------+--------------------------+</div><div class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="type">set</span> (<span class="number">0</span>.<span class="number">00</span> sec)</div></pre></td></tr></table></figure>

<p>后面在<a href="http://imysql.cn" target="_blank" rel="external">@叶金荣</a>的博客里面看到有个同学提出在雅虎一种方法来实现排序分页的SQL优化的，用他的方法我实际测试了下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select sql_no_cache id,uid,loginlocation,appname,logintime from t_user_log force index (idx_logintime) order by logintime limit 1000005,5;</span></div><div class="line">+---------+-----------+---------------------------------------------------------------------+--------------+------------+</div><div class="line"><span class="header">| id      | uid       | loginlocation                                                       | appname      | logintime  |</span></div><div class="line">+---------+-----------+---------------------------------------------------------------------+--------------+------------+</div><div class="line">| 1000006 | 111620882 | 亚太地区                                                            |              | 1406949591 |</div><div class="line">| 1000007 | 114237512 | 美国                                                                |              | 1406949591 |</div><div class="line">| 1000008 | 108382349 | 湖南省 电信                                                         | 发号中心     | 1406949591 |</div><div class="line">| 1000009 | 108410167 | 德国                                                                | 发号中心     | 1406949591 |</div><div class="line"><span class="header">| 1000013 |  60018858 | 北京市 北京搜狐互联网信息服务有限公司电信节点                       | 17173邮箱    | 1406949591 |</span></div><div class="line">+---------+-----------+---------------------------------------------------------------------+--------------+------------+</div><div class="line">5 rows in set (1.44 sec)</div><div class="line"></div><div class="line">mysql&gt; select sql<span class="emphasis">_no_</span>cache m2.id,m2.uid,m2.loginlocation,m2.appname,m2.logintime from t<span class="emphasis">_user_</span>log m1 , t<span class="emphasis">_user_</span>log m2 </div><div class="line">where m1.id = m2.id and m1.logintime &gt;= 1406949591 and (m1.id &gt; 1000005 or m1.logintime &gt; 1406949591) </div><div class="line"><span class="header">order by m1.logintime,m1.id limit 5;</span></div><div class="line">+---------+-----------+---------------------------------------------------------------------+--------------+------------+</div><div class="line"><span class="header">| id      | uid       | loginlocation                                                       | appname      | logintime  |</span></div><div class="line">+---------+-----------+---------------------------------------------------------------------+--------------+------------+</div><div class="line">| 1000006 | 111620882 | 亚太地区                                                            |              | 1406949591 |</div><div class="line">| 1000007 | 114237512 | 美国                                                                |              | 1406949591 |</div><div class="line">| 1000008 | 108382349 | 湖南省 电信                                                         | 发号中心     | 1406949591 |</div><div class="line">| 1000009 | 108410167 | 德国                                                                | 发号中心     | 1406949591 |</div><div class="line"><span class="header">| 1000013 |  60018858 | 北京市 北京搜狐互联网信息服务有限公司电信节点                       | 17173邮箱    | 1406949591 |</span></div><div class="line">+---------+-----------+---------------------------------------------------------------------+--------------+------------+</div><div class="line">5 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>哇哦，效率惊人啊。它的核心思想就是：通过extra过滤配合ID扫描，避免大量的回表操作，这样就达到了要取多少条，就扫描多少条的效果。但是这种方法有几个硬限制：<br><strong>1. 只能适用于没有任何条件的排序分页</strong><br><strong>2. 只能适用于固定的业务场景下，否则还要再次计算某一分页的minvalue_col1跟minvalue_id的值反而需要更大的开销</strong></p>
<h2 id="总结">总结</h2>
<p>回过头来我们总结下，无论是延迟关联或者是雅虎提出的方法，都是在于尽量少的扫描数据页来实现排序分页的优化。因此我们建议大分页SQL需要优化的情况下：</p>
<ol>
<li>一般情况下建议使用延迟关联这种方法</li>
<li>如果有特殊的业务场景（不需要使用条件过滤，可以直接固定的算法算出minvalue_col1跟minvalue_id），那么雅虎的做法值得你去借鉴</li>
</ol>
<blockquote>
<p>btw，优化不一定要死死遵循一定的原理，咱们的原则是尽量少的扫描数据页，在顺序读且m值不大的时候，全表扫描可能是一个更好的选择：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select sql_no_cache * from log_201409 where lastloginchannel = '1018' limit 1000000,1;                      </span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| username                  | loginip      | logintime           | lastloginchannel | regtime             | id      |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| xxxxxxxxxxxxxxx@17173.com | 60.167.xx.xx | 2014-09-03 22:24:10 | 1018             | 0000-00-00 00:00:00 | 2353297 |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line">1 row in set (1.38 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select sql_no_cache * from log_201409 ignore index (i_lastloginchannel,idx_1) where lastloginchannel = '1018' limit 1000000,1;</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| username                  | loginip      | logintime           | lastloginchannel | regtime             | id      |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line"><span class="header">| xxxxxxxxxxxxxxx@17173.com | 60.167.xx.xx | 2014-09-03 22:24:10 | 1018             | 0000-00-00 00:00:00 | 2353297 |</span></div><div class="line">+---------------------------+--------------+---------------------+------------------+---------------------+---------+</div><div class="line">1 row in set (0.77 sec)</div><div class="line"><span class="comment">//直接禁用lastloginchannel字段相关的索引，强制走全表扫描，效率比上面案例中的使用延迟关联还来的更快</span></div></pre></td></tr></table></figure>

<p>参考内容：<br><a href="http://imysql.com/2014/07/26/mysql-optimization-case-paging-optimize.shtml" target="_blank" rel="external">http://imysql.com/2014/07/26/mysql-optimization-case-paging-optimize.shtml</a><br><a href="http://www.vmcd.org/2014/07/advance-for-mysql-pagination/" target="_blank" rel="external">http://www.vmcd.org/2014/07/advance-for-mysql-pagination/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记得在很久以前我在公司内部做过一次MySQL优化分享里面说到一个使用延迟关联实现排序分页类型SQL的优化，这个案例在《高性能MySQL》的第二版还是第三版也有提及。</p>
<blockquote>
<p>延迟关联：通过覆盖索引返回所需数据行的主键，再通过主键获取所需数据。</p>
</blockquote>
<p>这里我们来看一个使用延迟关联优化排序分页SQL的案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select sql_no_cache * from t_user_log where appname = '发号中心' order by logintime limit 1000000,1;</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| id      | uid       | username                 | appname      | loginip         | loginlocation                      | logintime  | logintype | useragent |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| 2246895 | 114790028 | xxxxxxxxxxxxxx@17173.com | 发号中心     | 220.172.xxx.xxx | 贵州省黔南州都匀市 电信            | 1407055334 |         1 |           |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line">1 row in set (2.05 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select sql_no_cache a.* from t_user_log a inner join (select id from t_user_log where appname = '发号中心' order by logintime limit 1000000,1) b on a.id = b.id; </span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| id      | uid       | username                 | appname      | loginip         | loginlocation                      | logintime  | logintype | useragent |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line"><span class="header">| 2246895 | 114790028 | xxxxxxxxxxxxxx@17173.com | 发号中心     | 220.172.xxx.xxx | 贵州省黔南州都匀市 电信            | 1407055334 |         1 |           |</span></div><div class="line">+---------+-----------+--------------------------+--------------+-----------------+------------------------------------+------------+-----------+-----------+</div><div class="line">1 row in set (0.87 sec)</div></pre></td></tr></table></figure>

<p>确实使用延迟关联以后SQL效率提升了约135%左右。</p>
<h2 id="那么问题来了">那么问题来了</h2>
<ol>
<li>延迟关联的用法在InnoDB跟MyISAM两种引擎上是否有区别？</li>
<li>延迟关联是否优化排序分页SQL的最优方法？</li>
</ol>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
      <category term="SQL优化" scheme="http://hidba.ga/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL SQL优化系列]之连接查询]]></title>
    <link href="http://hidba.ga/2014/09/26/join-query-in-mysql/"/>
    <id>http://hidba.ga/2014/09/26/join-query-in-mysql/</id>
    <published>2014-09-26T07:49:36.000Z</published>
    <updated>2014-11-07T07:04:19.000Z</updated>
    <content type="html"><![CDATA[<p>MySQL的连接查询包括内连接（inner join）、外连接（left/right join，下文一律以left join代替）、交叉连接（在MySQL中等价于内连接，但是在标准SQL中是不等价的）、全连接（MySQL不支持full join，但是可以通过union构造），本文主要讲解一般我们在写SQL中最常用的：内连接以及外连接两种连接查询，通过一些案例来说明我们在使用关联查询中需要注意什么问题，要怎么做才能做到最优查询。</p>
<h2 id="重点说在前面">重点说在前面</h2>
<ol>
<li>MySQL对表连接至今只支持nested loop join，而不支持hash join，这个是MySQL不建议执行复杂关联查询的根源（MariaDB已经实现hash join）<blockquote>
<p>通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。</p>
</blockquote>
</li>
<li>优化的目标是尽可能减少关联查询中nested loop的循环次数，也就是说尽量缩小驱动表的结果集</li>
<li>inner join驱动顺序由优化器自己指定，如果优化器选择有误可以使用straight_join自己指定驱动顺序以达到优化的目的</li>
<li>left join驱动顺序是固定的，left join左边的表为驱动表，右边为匹配表，RIGHT JOIN则刚好相反<blockquote>
<p>其实这也不是绝对的，当left join跟inner join等价的时候，MySQL优化器就会自己选择驱动表，需求请见下文“容易混淆的地方”部分</p>
</blockquote>
</li>
<li>存在group by或者order by子句的关联查询中，如果引用的字段是驱动表的字段那么分组或者排序是可以使用索引的，如果引用的是其他匹配表的字段，那边分组或者排序动作则无法使用索引</li>
<li>在MySQL5.6以前的版本关联子查询可以用关联查询来替代优化（MySQL5.6或者更新的版本或者MariaDB等就无需替代，优化器会自动帮你优化处理）</li>
<li>在MySQL5.6以及以后的版本中，缩小匹配表的结果集也能达到优化的效果</li>
</ol>
<a id="more"></a>

<h2 id="什么叫连接查询">什么叫连接查询</h2>
<p>首先我们要搞清楚什么叫连接查询，内连接跟外连接又有什么区别？</p>
<p><strong>内连接</strong></p>
<pre><code><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">inner</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id = b.id;</span>
等价于
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> a,b <span class="keyword">where</span> a.id = b.id;</span>
</code></pre><p><strong>外连接</strong></p>
<pre><code><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id = b.id;</span>
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">right</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id = b.id;</span>
</code></pre><p>简单来说内连接就是检索出与连接条件完全匹配的数据行；而外连接则是保留了所有驱动表的数据，匹配表中无法匹配的数据则以NULL输出，下面是一个简单的例子。</p>
<p><strong><em>test 1-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; create table a (id int not null , name varchar(10) not null default '<span class="emphasis">');</span></div><div class="line">Query OK, 0 rows affected (0.06 sec)</div><div class="line"></div><div class="line">mysql&gt; create table b (id int not null , name varchar(10) not null default '<span class="emphasis">'); </span></div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; insert into a values (1,<span class="emphasis">'aaa'</span>),(2,<span class="emphasis">'bbb'</span>),(3,<span class="emphasis">'ccc'</span>);</div><div class="line">Query OK, 3 rows affected (0.00 sec)</div><div class="line">Records: 3  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; insert into b values (1,<span class="emphasis">'aaa'</span>),(3,<span class="emphasis">'ccc'</span>),(4,<span class="emphasis">'ddd'</span>); </div><div class="line">Query OK, 3 rows affected (0.00 sec)</div><div class="line">Records: 3  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select * from a inner join b on a.id = b.id;</span></div><div class="line">+----+------+----+------+</div><div class="line"><span class="header">| id | name | id | name |</span></div><div class="line">+----+------+----+------+</div><div class="line">|  1 | aaa  |  1 | aaa  |</div><div class="line"><span class="header">|  3 | ccc  |  3 | ccc  |</span></div><div class="line">+----+------+----+------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"><span class="comment">// 这就是内连接</span></div><div class="line"></div><div class="line"><span class="header">mysql&gt; select * from a left join b on a.id = b.id;</span></div><div class="line">+----+------+------+------+</div><div class="line"><span class="header">| id | name | id   | name |</span></div><div class="line">+----+------+------+------+</div><div class="line">|  1 | aaa  |    1 | aaa  |</div><div class="line">|  3 | ccc  |    3 | ccc  |</div><div class="line"><span class="header">|  2 | bbb  | NULL | NULL |</span></div><div class="line">+----+------+------+------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"><span class="comment">// 这就是外连接</span></div></pre></td></tr></table></figure>

<h2 id="使用straight_join优化inner_join">使用straight_join优化inner join</h2>
<p>内连接跟外连接的区别在于返回值范围不同，驱动表无法自行选择，其余就没什么太大的区别。同样需要注意驱动表选择、需要注意分组或者排序的选择等等。这里我们通过下面这个案例来演示下怎么使用straight_join自己指定驱动表来优化inner join语句。</p>
<p><strong>测试环境</strong>（下面所有的SQL测试都是基于同样的环境）</p>
<blockquote>
<p>Linux as 5.8<br>Percona 5.6.13 &amp; MySQL 5.5.28<br>t_user InnoDB 10万数据<br>t_user_log InnoDB 约3000万数据</p>
</blockquote>
<p>执行一个简单的关联查询</p>
<p><strong><em>test 2-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select a.* from t_user_log a inner join t_user b on a.uid = b.uid order by a.logintime desc limit <span class="number">100</span>;</div><div class="line"><span class="keyword">...</span></div><div class="line"><span class="number">100</span> rows <span class="keyword">in</span> set (<span class="number">17</span> min <span class="number">41.83</span> sec)</div></pre></td></tr></table></figure>

<p>我们来看下它的执行计划：MySQL的优化器选择了t_user来做驱动表，根据我们之前说的存在order by子句的情况，MySQL优化器存在无法使用索引（logintime）来完成排序动作，只能通过创建临时表来保持临时结果集，然后在临时结果集中完成排序同坐，于是就产生了Using temporary。我们完全可以预见这个SQL执行是有多么慢多么的耗费服务器资源特别是IO资源，实际上在我测试的过程中服务器的iowait%一直保持在6%左右。</p>
<p><strong><em>test 2-2</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; explain select a.* from t_user_log a inner join t_user b on a.uid = b.uid order by a.logintime desc limit 100;</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+----------------------------------------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys         | key     | key_len | ref                | rows   | Extra                                        |</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+----------------------------------------------+</div><div class="line">|  1 | SIMPLE      | b     | index | idx<span class="emphasis">_uid               | idx_</span>uid | 4       | NULL               | 100105 | Using index; Using temporary; Using filesort | </div><div class="line"><span class="header">|  1 | SIMPLE      | a     | ref   | uid_logintime,idx_uid | idx_uid | 4       | join_test_db.b.uid |      5 | NULL                                         | </span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+----------------------------------------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; show index from t<span class="emphasis">_user_</span>log;</div><div class="line"><span class="bullet">...</span></div><div class="line">| t<span class="emphasis">_user_</span>log |          1 | logintime     |            1 | logintime   | A         |     3668150 |     NULL | NULL   |      | BTREE      |         |               ...</div></pre></td></tr></table></figure>

<p>MySQL优化器选择驱动表是粗暴的，简单的以当前条件返回结果集来判断，结构集小的就是驱动表。在这个案例中除了排序并无其他条件，也就是说结果集是3000万比10万，于是MySQL优化器选择了t_user当驱动表，然后就发生了上面的一幕。<br>如果说我们要优化这个SQL，那么首先应该就是避免Using temporary产生，也就是说我们需要在索引中完成排序动作。那么根据我们上面描述的带有order by自己的关联查询的情况，如果order by子句想使用索引那么就必须把引用字段所在的表作为驱动表，也就是案例中的t_user_log，这里我使用straight_join将t_user_log设置成驱动表看看会是什么情况。</p>
<p><strong><em>test 2-3</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select a.* from t<span class="emphasis">_user_</span>log a straight<span class="emphasis">_join t_</span>user b on a.uid = b.uid order by a.logintime desc limit 100;</div><div class="line"><span class="bullet">...</span></div><div class="line">100 rows in set (0.14 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select a.* from t_user_log a straight_join t_user b on a.uid = b.uid order by a.logintime desc limit 100;</span></div><div class="line">+----+-------------+-------+-------+-----------------------+-----------+---------+--------------------+------+-------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys         | key       | key_len | ref                | rows | Extra       |</span></div><div class="line">+----+-------------+-------+-------+-----------------------+-----------+---------+--------------------+------+-------------+</div><div class="line">|  1 | SIMPLE      | a     | index | uid<span class="emphasis">_logintime,idx_</span>uid | logintime | 4       | NULL               |  100 | NULL        | </div><div class="line"><span class="header">|  1 | SIMPLE      | b     | ref   | idx_uid               | idx_uid   | 4       | join_test_db.a.uid |    1 | Using index | </span></div><div class="line">+----+-------------+-------+-------+-----------------------+-----------+---------+--------------------+------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>很明显MySQL优化器乖乖的按照我们的引导将t_user_log设置成驱动表后使用logintime(logintime)索引在索引中完成排序动作，效率提升是非常明显的。17′41.87″ vs 0.14″，效率提升了7500倍+。</p>
<p>这个案例说明了两件事：</p>
<ol>
<li><strong>一个是straight_join确实可以用来指定inner join的驱动表</strong></li>
<li><strong>一个是关联查询驱动表选择非常重要</strong></li>
</ol>
<p>有一点需要注意的是：我们前面说要尽量缩小驱动表的结果集，但是这里却选择了一个超大表来做为驱动表，但其实两者是在一定程度上是不相悖的。因为缩小驱动表结果集实际上是为了减少nested loop的次数，而我们修改了驱动表以后，排序动作直接在索引完成，优化器直接按照logintime desc的顺序进行扫描，只要返回记录数等于100时就可以完成查询操作，实际的nested loop次数是很少的。而未修改前的SQL之所以需要执行那么久是因为它的排序无法使用索引，所以必须先等待临时结果集生成，而且是全量生成，也就是说需要在约3000万行的表里进行10万次查询，然后把结果聚集到一张临时表再进行排序选出100行记录。</p>
<h2 id="通过缩小驱动表结果集来优化关联查询">通过缩小驱动表结果集来优化关联查询</h2>
<p>还是上面的例子，这里我们用count(*)来做一次全表扫描的测试再看看驱动表应该怎么选。</p>
<p><strong><em>test 3-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a straight_join t_user b on a.uid = b.uid ;          </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (16 min 57.25 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user b straight_join t_user_log a on a.uid = b.uid ;        </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (0.74 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a straight_join t_user b on a.uid = b.uid ;</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+----------+-------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys         | key     | key_len | ref                | rows     | Extra       |</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | a     | index | uid<span class="emphasis">_logintime,idx_</span>uid | idx<span class="emphasis">_uid | 4       | NULL               | 29345201 | Using index | </span></div><div class="line">|  1 | SIMPLE      | b     | ref   | idx_uid               | idx<span class="emphasis">_uid | 4       | join_</span>test<span class="emphasis">_db.a.uid |        1 | Using index | </span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+----------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user b straight_join t_user_log a on a.uid = b.uid ;        </span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+-------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys         | key     | key_len | ref                | rows   | Extra       |</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | b     | index | idx<span class="emphasis">_uid               | idx_</span>uid | 4       | NULL               | 100105 | Using index | </div><div class="line"><span class="header">|  1 | SIMPLE      | a     | ref   | uid_logintime,idx_uid | idx_uid | 4       | join_test_db.b.uid |      5 | Using index | </span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>通过这个实验我们可以证明：驱动表结果集越小越好。</p>
<h2 id="子查询说明">子查询说明</h2>
<p>以下面四个SQL为例：</p>
<ol>
<li>第一个是我们正常的关联子查询的写法</li>
<li>第二个是在MySQL5.6以前版本中SQL1的等价写法</li>
<li>第三个是采用关联查询的优化写法</li>
<li>第四个外连接改写关联子查询，等价于SQL3的内连接写法</li>
</ol>
<p><strong><em>test 4-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a where a.uid in (select uid from t_user);</span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (0.81 sec)</div><div class="line"><span class="comment">// 在MySQL5.6以前的版本，MySQL优化器认为把外层表压到子查询中能够更高效的找到数据行，也就是等价于SQL2的写法</span></div><div class="line"><span class="comment">// 但是到MySQL5.6以及以后的版本中MySQL优化器则不是这么认为了，它们会自动按照关联查询的逻辑来执行关联子查询</span></div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a where exists (select uid from t_user b where a.uid = b.uid);               </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (1 min 34.70 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a inner join t_user b on a.uid = b.uid;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (0.82 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a left  join t_user b on a.uid = b.uid where b.uid is not null;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (0.79 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a where a.uid in (select uid from t_user);</span></div><div class="line">+----+-------------+--------+-------+-----------------------+---------+---------+-------------------------+--------+------------------------+</div><div class="line"><span class="header">| id | select_type | table  | type  | possible_keys         | key     | key_len | ref                     | rows   | Extra                  |</span></div><div class="line">+----+-------------+--------+-------+-----------------------+---------+---------+-------------------------+--------+------------------------+</div><div class="line">|  1 | SIMPLE      | t<span class="emphasis">_user | index | idx_</span>uid               | idx<span class="emphasis">_uid | 4       | NULL                    | 100105 | Using index; LooseScan | </span></div><div class="line">|  1 | SIMPLE      | a      | ref   | uid_logintime,idx<span class="emphasis">_uid | idx_</span>uid | 4       | join<span class="emphasis">_test_</span>db.t<span class="emphasis">_user.uid |      5 | Using index            | </span></div><div class="line">+----+-------------+--------+-------+-----------------------+---------+---------+-------------------------+--------+------------------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a where exists (select uid from t_user b where a.uid = b.uid);  </span></div><div class="line">+----+--------------------+-------+-------+---------------+---------+---------+--------------------+----------+--------------------------+</div><div class="line"><span class="header">| id | select_type        | table | type  | possible_keys | key     | key_len | ref                | rows     | Extra                    |</span></div><div class="line">+----+--------------------+-------+-------+---------------+---------+---------+--------------------+----------+--------------------------+</div><div class="line">|  1 | PRIMARY            | a     | index | NULL          | idx<span class="emphasis">_uid | 4       | NULL               | 29345201 | Using where; Using index | </span></div><div class="line">|  2 | DEPENDENT SUBQUERY | b     | ref   | idx_uid       | idx<span class="emphasis">_uid | 4       | join_</span>test<span class="emphasis">_db.a.uid |        1 | Using index              | </span></div><div class="line">+----+--------------------+-------+-------+---------------+---------+---------+--------------------+----------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a inner join t_user b on a.uid = b.uid;</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+-------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys         | key     | key_len | ref                | rows   | Extra       |</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | b     | index | idx<span class="emphasis">_uid               | idx_</span>uid | 4       | NULL               | 100105 | Using index | </div><div class="line"><span class="header">|  1 | SIMPLE      | a     | ref   | uid_logintime,idx_uid | idx_uid | 4       | join_test_db.b.uid |      5 | Using index | </span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a left  join t_user b on a.uid = b.uid where b.uid is not null;</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+--------------------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys         | key     | key_len | ref                | rows   | Extra                    |</span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+--------------------------+</div><div class="line">|  1 | SIMPLE      | b     | index | idx<span class="emphasis">_uid               | idx_</span>uid | 4       | NULL               | 100105 | Using where; Using index | </div><div class="line"><span class="header">|  1 | SIMPLE      | a     | ref   | uid_logintime,idx_uid | idx_uid | 4       | join_test_db.b.uid |      5 | Using index              | </span></div><div class="line">+----+-------------+-------+-------+-----------------------+---------+---------+--------------------+--------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>这里我们再来看看SQL1与SQL2在MySQL5.5版本中的效率已经执行计划</p>
<p><strong><em>test 4-2</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a where a.uid in (select uid from t_user); </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (1 min 5.13 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a where exists (select uid from t_user b where a.uid = b.uid);   </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|  1172206 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (1 min 24.81 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a where a.uid in (select uid from t_user);</span></div><div class="line">+----+--------------------+--------+----------------+---------------+---------+---------+------+----------+--------------------------+</div><div class="line"><span class="header">| id | select_type        | table  | type           | possible_keys | key     | key_len | ref  | rows     | Extra                    |</span></div><div class="line">+----+--------------------+--------+----------------+---------------+---------+---------+------+----------+--------------------------+</div><div class="line">|  1 | PRIMARY            | a      | index          | NULL          | idx<span class="emphasis">_uid | 4       | NULL | 30736327 | Using where; Using index | </span></div><div class="line">|  2 | DEPENDENT SUBQUERY | t_user | index<span class="emphasis">_subquery | idx_</span>uid       | idx<span class="emphasis">_uid | 4       | func |        1 | Using index              | </span></div><div class="line">+----+--------------------+--------+----------------+---------------+---------+---------+------+----------+--------------------------+</div><div class="line">2 rows in set (0.01 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a where exists (select uid from t_user b where a.uid = b.uid);   </span></div><div class="line">+----+--------------------+-------+-------+---------------+---------+---------+--------------------+----------+--------------------------+</div><div class="line"><span class="header">| id | select_type        | table | type  | possible_keys | key     | key_len | ref                | rows     | Extra                    |</span></div><div class="line">+----+--------------------+-------+-------+---------------+---------+---------+--------------------+----------+--------------------------+</div><div class="line">|  1 | PRIMARY            | a     | index | NULL          | idx<span class="emphasis">_uid | 4       | NULL               | 30736327 | Using where; Using index | </span></div><div class="line">|  2 | DEPENDENT SUBQUERY | b     | ref   | idx_uid       | idx<span class="emphasis">_uid | 4       | join_</span>test<span class="emphasis">_db.a.uid |        1 | Using index              | </span></div><div class="line">+----+--------------------+-------+-------+---------------+---------+---------+--------------------+----------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<h2 id="容易混淆的地方">容易混淆的地方</h2>
<p>下面这两个SQL是等价的吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t_user_log a <span class="keyword">left</span> <span class="keyword">join</span> t_user b <span class="keyword">on</span> a.uid = b.uid <span class="keyword">and</span> b.city = <span class="number">78</span>;</span> </div><div class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t_user_log a <span class="keyword">left</span> <span class="keyword">join</span> t_user b <span class="keyword">on</span> a.uid = b.uid <span class="keyword">where</span> b.city = <span class="number">78</span>;</span></div></pre></td></tr></table></figure>

<p>答案是否定的，因为前者在匹配表中加了过滤条件，而后者在关联结果中加了过滤条件，前者不影响驱动表检索出来的数据（与匹配表无法匹配的数据依然会检索出来，只是匹配表字段部分值等于NULL），后者影响驱动表检索出来的数据（因为在结果集中直接被过滤掉了）。</p>
<p><strong><em>test 5-2</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a left join t_user b on a.uid = b.uid and b.city = 78;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">| 30560213 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (1 min 6.83 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a left join t_user b on a.uid = b.uid where b.city = 78;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|    10009 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>

<p>再看看这样的两个SQL等价吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t_user_log a <span class="keyword">left</span> <span class="keyword">join</span> t_user b <span class="keyword">on</span> a.uid = b.uid <span class="keyword">where</span> b.city = <span class="number">78</span>;</span></div><div class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t_user_log a <span class="keyword">inner</span> <span class="keyword">join</span> t_user b <span class="keyword">on</span> a.uid = b.uid <span class="keyword">where</span> b.city = <span class="number">78</span>;</span></div></pre></td></tr></table></figure>

<p>答案是肯定的，因为前者在关联结果中加了匹配表的过滤条件，后者是内关联等价于在关联结果中过滤数据，因此两者是等价的。<br>也就是在这种情况下MySQL优化器会认为：<strong>外关联等价于内关联，会由优化器自行选择驱动表，而不是直接以left join左边的t_user_log表作为驱动表。</strong></p>
<p><strong><em>test 5-2</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select count(*) <span class="keyword">from</span> t_user_log a left join t_user b on a.uid = b.uid where b.city = <span class="number">78</span>;</div><div class="line">+----+-------------+-------+------+---------------------------+---------+---------+--------------------+------+--------------------------+</div><div class="line">| id | select_type | table | <span class="keyword">type</span> | possible_keys             | key     | key_len | <span class="keyword">ref</span>                | rows | <span class="type">Extra</span>                    |</div><div class="line">+----+-------------+-------+------+---------------------------+---------+---------+--------------------+------+--------------------------+</div><div class="line">|  <span class="number">1</span> | <span class="type">SIMPLE</span>      | b     | <span class="keyword">ref</span>  | idx_uid,idx_1,idx_2,idx_4 | idx_2   | <span class="number">1</span>       | <span class="keyword">const</span>              |  <span class="number">942</span> | <span class="type">Using</span> where; <span class="type">Using</span> index | </div><div class="line">|  <span class="number">1</span> | <span class="type">SIMPLE</span>      | a     | <span class="keyword">ref</span>  | uid_logintime,idx_uid     | idx_uid | <span class="number">4</span>       | join_test_db.b.uid |    <span class="number">5</span> | <span class="type">Using</span> index              | </div><div class="line">+----+-------------+-------+------+---------------------------+---------+---------+--------------------+------+--------------------------+</div><div class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="type">set</span> (<span class="number">0</span>.<span class="number">00</span> sec)</div></pre></td></tr></table></figure>

<p>接下来再看看这两个SQL是否等价。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t_user_log a <span class="keyword">left</span> <span class="keyword">join</span> t_user b <span class="keyword">on</span> a.uid = b.uid <span class="keyword">where</span> a.logintype = <span class="number">3</span>;</span>  </div><div class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t_user_log a <span class="keyword">inner</span> <span class="keyword">join</span> t_user b <span class="keyword">on</span> a.uid = b.uid <span class="keyword">where</span> a.logintype = <span class="number">3</span>;</span></div></pre></td></tr></table></figure>

<p>很多同学看了<strong><em>test 5-2</em></strong>的两个SQL是等价，自然也觉得<strong><em>test 5-3</em></strong>这两个SQL也是等价的。但是很遗憾，结果是不等价。</p>
<p><strong><em>test 5-3</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a left join t_user b on a.uid = b.uid where a.logintype = 3;  </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">| 11461228 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (31.15 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a inner join t_user b on a.uid = b.uid where a.logintype = 3;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">|      170 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (47.63 sec)</div></pre></td></tr></table></figure>

<p>因为这两个SQL都是在结果集中进行数据过滤，两者的结果集不同，因此过滤结果也可能不同，所以两个SQL是不等价的。<br>简单来说：<strong>关联查询where后面部分如果带有匹配表上的查询条件，那么这个外关联SQL可以等价于内关联SQL（匹配表.clo is null除外）。</strong></p>
<h2 id="缩小匹配表结果集能达到优化的效果吗">缩小匹配表结果集能达到优化的效果吗</h2>
<p>通过上面的一些说明与实验我们知道缩小驱动表的结果集能够优化连接查询，那么如果在驱动表的结果集无法缩小，且无法替换驱动表的情况下，通过所缩小匹配表的结果集能达到优化效果吗？</p>
<p><strong><em>test 6-1</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a left join ( select * from t_user where city = 78 )b on a.uid = b.uid where b.id is null;</span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">| 30550204 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (23.16 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a left join t_user b on a.uid = b.uid and b.city = 78 where b.id is null;   </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">| 30550204 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (1 min 10.74 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a left join ( select * from t_user where city = 78 )b on a.uid = b.uid where b.id is null;</span></div><div class="line">+----+-------------+------------+-------+---------------+-------------+---------+--------------------+----------+-------------------------+</div><div class="line"><span class="header">| id | select_type | table      | type  | possible_keys | key         | key_len | ref                | rows     | Extra                   |</span></div><div class="line">+----+-------------+------------+-------+---------------+-------------+---------+--------------------+----------+-------------------------+</div><div class="line">|  1 | PRIMARY     | a          | index | NULL          | idx<span class="emphasis">_uid     | 4       | NULL               | 29345201 | Using index             | </span></div><div class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ref   | &lt;auto_key1&gt;   | &lt;auto<span class="emphasis">_key1&gt; | 4       | join_</span>test<span class="emphasis">_db.a.uid |       15 | Using where; Not exists | </span></div><div class="line">|  2 | DERIVED     | t_user     | ref   | idx<span class="emphasis">_2,idx_</span>4   | idx<span class="emphasis">_2       | 1       | const              |      942 | NULL                    | </span></div><div class="line">+----+-------------+------------+-------+---------------+-------------+---------+--------------------+----------+-------------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a left join t_user b on a.uid = b.uid and b.city = 78 where b.id is null;                         </span></div><div class="line">+----+-------------+-------+-------+---------------------------+---------+---------+--------------------+----------+-------------------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys             | key     | key_len | ref                | rows     | Extra                   |</span></div><div class="line">+----+-------------+-------+-------+---------------------------+---------+---------+--------------------+----------+-------------------------+</div><div class="line">|  1 | SIMPLE      | a     | index | NULL                      | idx<span class="emphasis">_uid | 4       | NULL               | 29345201 | Using index             | </span></div><div class="line">|  1 | SIMPLE      | b     | ref   | idx_uid,idx<span class="emphasis">_1,idx_</span>2,idx<span class="emphasis">_4 | idx_</span>uid | 4       | join<span class="emphasis">_test_</span>db.a.uid |        1 | Using where; Not exists | </div><div class="line"><span class="code">+----+</span>-------------<span class="code">+-------+</span>-------<span class="code">+---------------------------+</span>---------<span class="code">+---------+</span>--------------------<span class="code">+----------+</span>-------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>从执行计划上看第二个SQL应该比第一个SQL更优，但实际结果却是第一个SQL执行效率更高，原因也许就出在我暂时还不明白的<auto_key1>上，这个是MySQL5.6以后才出现的，放在My5.5及以前的版本中是没有的，自然执行的效率也是可以预见的非常非常低，下面是同样的SQL在MySQL5.5版本执行的结果。</auto_key1></p>
<p><strong><em>test 6-2</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(<span class="strong">*) from t_user_log a left join ( select *</span> from t<span class="emphasis">_user where city = 78 )b on a.uid = b.uid where b.id is null;</span></div><div class="line">...</div><div class="line">// 执行超过10分钟还没出结果，直接被我X掉了</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select count(*) from t_user_log a left join t_user b on a.uid = b.uid and b.city = 78 where b.id is null;  </span></div><div class="line">+----------+</div><div class="line"><span class="header">| count(*) |</span></div><div class="line">+----------+</div><div class="line"><span class="header">| 30550204 | </span></div><div class="line">+----------+</div><div class="line">1 row in set (1 min 7.68 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select count(*) from t_user_log a left join ( select * from t_user where city = 78 )b on a.uid = b.uid where b.id is null;</span></div><div class="line">+----+-------------+------------+-------+----------------+---------+---------+------+----------+-------------------------+</div><div class="line"><span class="header">| id | select_type | table      | type  | possible_keys  | key     | key_len | ref  | rows     | Extra                   |</span></div><div class="line">+----+-------------+------------+-------+----------------+---------+---------+------+----------+-------------------------+</div><div class="line">|  1 | PRIMARY     | a          | index | NULL           | idx<span class="emphasis">_uid | 4       | NULL | 30736327 | Using index             | </span></div><div class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ALL   | NULL           | NULL    | NULL    | NULL |      943 | Using where; Not exists | </div><div class="line">|  2 | DERIVED     | t_user     | ref   | idx<span class="emphasis">_city,idx_</span>2 | idx<span class="emphasis">_2   | 1       |      |      942 |                         | </span></div><div class="line">+----+-------------+------------+-------+----------------+---------+---------+------+----------+-------------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; explain select  count(*) from t_user_log a left join t_user b on a.uid = b.uid and b.city = 78 where b.id is null;                        </span></div><div class="line">+----+-------------+-------+-------+------------------------+---------+---------+--------------------+----------+-------------------------+</div><div class="line"><span class="header">| id | select_type | table | type  | possible_keys          | key     | key_len | ref                | rows     | Extra                   |</span></div><div class="line">+----+-------------+-------+-------+------------------------+---------+---------+--------------------+----------+-------------------------+</div><div class="line">|  1 | SIMPLE      | a     | index | NULL                   | idx<span class="emphasis">_uid | 4       | NULL               | 30736327 | Using index             | </span></div><div class="line">|  1 | SIMPLE      | b     | ref   | idx_uid,idx<span class="emphasis">_city,idx_</span>2 | idx<span class="emphasis">_uid | 4       | join_</span>test<span class="emphasis">_db.a.uid |        1 | Using where; Not exists | </span></div><div class="line">+----+-------------+-------+-------+------------------------+---------+---------+--------------------+----------+-------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>果然如我们预料在MySQL5.5版本上SQL1执行的效率低的可怕，至于MySQL5.6上<strong>为什么缩小匹配表结果集能达到优化</strong>就等下回分解吧。</p>
<h2 id="说在后面">说在后面</h2>
<p>关于MySQL的SQL优化，照本宣科达是不到什么效果的，只有了解原则结合实际场景（数据密度，数据分布，应用场景等等）才能得出最优的优化方案，照本宣科生搬硬套往往只会有反效果。</p>
<h2 id="遗留问题">遗留问题</h2>
<p>MySQL5.6确实有做了相关优化吗：<strong>缩小匹配表结果集能达到优化关联查询</strong>？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>MySQL的连接查询包括内连接（inner join）、外连接（left/right join，下文一律以left join代替）、交叉连接（在MySQL中等价于内连接，但是在标准SQL中是不等价的）、全连接（MySQL不支持full join，但是可以通过union构造），本文主要讲解一般我们在写SQL中最常用的：内连接以及外连接两种连接查询，通过一些案例来说明我们在使用关联查询中需要注意什么问题，要怎么做才能做到最优查询。</p>
<h2 id="重点说在前面">重点说在前面</h2>
<ol>
<li>MySQL对表连接至今只支持nested loop join，而不支持hash join，这个是MySQL不建议执行复杂关联查询的根源（MariaDB已经实现hash join）<blockquote>
<p>通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。</p>
</blockquote>
</li>
<li>优化的目标是尽可能减少关联查询中nested loop的循环次数，也就是说尽量缩小驱动表的结果集</li>
<li>inner join驱动顺序由优化器自己指定，如果优化器选择有误可以使用straight_join自己指定驱动顺序以达到优化的目的</li>
<li>left join驱动顺序是固定的，left join左边的表为驱动表，右边为匹配表，RIGHT JOIN则刚好相反<blockquote>
<p>其实这也不是绝对的，当left join跟inner join等价的时候，MySQL优化器就会自己选择驱动表，需求请见下文“容易混淆的地方”部分</p>
</blockquote>
</li>
<li>存在group by或者order by子句的关联查询中，如果引用的字段是驱动表的字段那么分组或者排序是可以使用索引的，如果引用的是其他匹配表的字段，那边分组或者排序动作则无法使用索引</li>
<li>在MySQL5.6以前的版本关联子查询可以用关联查询来替代优化（MySQL5.6或者更新的版本或者MariaDB等就无需替代，优化器会自动帮你优化处理）</li>
<li>在MySQL5.6以及以后的版本中，缩小匹配表的结果集也能达到优化的效果</li>
</ol>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
      <category term="SQL优化" scheme="http://hidba.ga/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL案例]之Discuz大表拆分]]></title>
    <link href="http://hidba.ga/2014/09/25/separate-table/"/>
    <id>http://hidba.ga/2014/09/25/separate-table/</id>
    <published>2014-09-25T12:19:18.000Z</published>
    <updated>2014-11-07T07:04:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>相信很多用discuz搭建论坛服务的同学都有这个体验，整个数据库表都是MyISAM引擎，一旦帖子数量到一定量级的时候神马操作都是巨慢无比（MyISAM的各种缺点这里暂且不提）。以此为背景，我们打算对discuz论坛进行改版，简单说来就是彻底抛弃原有的归档功能直接分100张表，按照帖子ID取模分发数据，然后把新表都改成InnoDB引擎。</p>
<p>以这件事为背景，对这次升级过程中数据库的操作做一个记录以及简单分析。抛开前期准备，后期处理等等步骤，这里我们就说下中间的重要环节。</p>
<blockquote>
<p>1.在帖子表里面新增一个字段，且加一条索引<br>2.更新新增字段的值为：mod(tid,100)+1<br>3.创建一个tempfs分区（需要比帖子表.MYD文件大）<br>4.使用select into oufile并发导出数据<br>5.增大innodb_buffer_pool_size,max_allowed_packet，缩小key_buffer_size<br>6.使用load data infile并发导入数据</p>
</blockquote>
<p>中间的数据分表的核心步骤大概就是这么几步，下来我们逐一来讲。</p>
<a id="more"></a>

<h1 id="分析">分析</h1>
<h2 id="方案的演化">方案的演化</h2>
<p>整个分表的方案变化大概是这样的：</p>
<blockquote>
<p>第一个方案：由开发同学直接写程序逐条导入，但是马上被我们pass了，1亿四千万行数据逐行插入在时间上是不可接受的。<br>第二个方案：mysqldump -w，但是考虑到新表是innodb需要新增一个自增主键，这样导入会有问题，所以第二个方案也被pass了。<br>第三个方案：select into outfile + load data infile，但是这里同样存在一个问题：MySQL不支持函数索引，所以mod(tid,100)+1=x这样是走不了索引。最后只能使用折中的临时方案：新增一个临时字段xxid用来存放mod(tid,100)+1计算后的值，select into outfile的时候直接按xxid查询就可以走索引了。</p>
</blockquote>
<h2 id="DDL_&amp;_UPDATE的优化">DDL &amp; UPDATE的优化</h2>
<blockquote>
<p>一般熟悉数据库的人都有这么一个认知：在你大量更新或者插入数据的时候，最好先删除或者禁用掉索引，等数据插入或者更新完成之后再创建索引，但是这里我们确实先创建了索引再更新数据，这是为什么？</p>
</blockquote>
<p>我们来看下这三种方案：</p>
<blockquote>
<p>方案1：alter table t add col, add index; update table set xxid1=xxx;<br>方案2：alter table t add col, add index; alter table t disable keys; update table set xxid1=xxx; alter table t enable keys;<br>方案3：alter table t add col;  update table set xxid1=xxx; alter table t add index;</p>
</blockquote>
<p>按照一般的习惯我们会选择第二种或者第三种方案，因为它们符合优化规则，在批量更新或者插入数据前先不要创建索引或者先禁用索引。其中方案二可能是最优的，因为MyISAM引擎对disable/enable keys是有优化的，我们来看这么一段说明：</p>
<blockquote>
<p>ALTER TABLE…DISABLE KEYS让MySQL停止更新MyISAM表中的非唯一索引。然后使用ALTER TABLE … ENABLE KEYS重新创建丢失的索引。进行此操作时，MySQL采用一种特殊的算法，比一个接一个地插入关键字要快很多。因此，在进行成批插入操作前先使关键字禁用可以大大地加快速度。</p>
</blockquote>
<p>那么我们大致可以得出方案2&gt;方案3&gt;方案1，但是从下图的测试结果看却不是这么一回事？<br><img src="http://image-myrock-github-io.qiniudn.com/update_index_time_diff.jpg" alt="image"></p>
<ol>
<li>这张表原本就存在1100W行记录，属于一张不小的表，而且在这次操作中需要新增一个字段，也就是第一个操作都是一个ddl动作；</li>
<li>在MySQL里面ddl动作是可以合并的，合并以后只会产生一次临时表动作，因此1次ddl耗时绝对小于2次ddl耗时；</li>
<li>ALTER TABLE…DISABLE/ENABLE KEYS针对的是MyISAM（非InnoDB表）的所有非唯一索引，注意是所有而不是更新目标字段的的索引，而本次测试表中除了主键以外一共有6条非唯一索引；</li>
</ol>
<p>基于以上几个原因，所以实际的结果是方案1&gt;方案2&gt;方案3。另外为了验证，我么干掉了其他5条非唯一索引，enable keys耗时从161秒降低到45秒，也就是说如果<strong>在一个少量的非唯一索引的环境中，方案二才是最优选择</strong>。</p>
<p>Ps：从上面实验数据确实可以看出，有没有索引对数据更新/插入确实存在很大的影响，对一个定长4字节字段加一条索引，数据更新的效率就差了超过100%了，所以以后类似的问题大家需要多多注意。</p>
<p><strong>还有一点要说明的是</strong></p>
<blockquote>
<p>我们在ddl以及update的时候没有对数据库做任何buffer优化设置，其实在一开始的时候我一直觉得加大：key_buffer_size、sort_buffer_size、read_buffer_size、tmp_table_size、max_heap_table_size几个参数可以加速ddl跟update的效率，实际上经过几次测试几乎是没有提升的。key_buffer_size只是缓存了索引数据，其他几个buffer分别是排序区缓存、表顺序查询缓存以及临时表大小设置，不懂为什么MyISAM为什么这样做不能加速ddl，还有如果是InnoDB呢（读不懂源码只能靠猜测，真蛋疼）？我一直以为是可以的，找个时间要做个实验看看。</p>
</blockquote>
<h2 id="为什么使用tmpfs">为什么使用tmpfs</h2>
<p>使用tempfs来装载MyISAM的数据文件，能够加速数据导出效率，而且提升超过100%。<br>一开始也没想到这个方法，只是在测试的时候发现为什么总是第一次效率很低，第二次效率就非常高，提升超过100%。首先我想到的是key_buffer，但是key_buffer只是缓存了索引数据，为了验证重启了数据库再测试发现效率还是高导出速度还是很快。如果不是key_buffer，那是可能就是Linux的cache。为了验证这个想法，我把cache释放掉，再执行导出操作，果然又变成第一次那样很慢。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sync && echo <span class="number">3</span> &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches;</div></pre></td></tr></table></figure>

<p>但是还是存在问题，本地文件导入到cache中的只有访问的部分，也就是说每次执行select into outfile操作都是很慢，只有第二次执行相同数据导出的时候效率才会提升，这样一来对我们的操作其实是没有帮助的，除非我们能够事先把整个数据文件导入到内存中。<br>于是就挂载了一个tmpfs，然后把.MYD文件丢进去再link到datadir，再测试果然效率刚刚的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> /home/memdir</div><div class="line">mount tmpfs /home/memdir/ -<span class="keyword">t</span> tmpfs -<span class="keyword">o</span> size=<span class="number">10</span><span class="keyword">g</span></div><div class="line"><span class="keyword">cp</span> pre_forum_post_2.MYD /home/memdir/</div><div class="line">mv pre_forum_post_2.MYD pre_forum_post_2.MYD.backup</div><div class="line"><span class="keyword">ln</span> -<span class="keyword">s</span> /home/memdir/pre_forum_post_2.MYD  ./</div></pre></td></tr></table></figure>

<h2 id="数据导出">数据导出</h2>
<p>开始导出，这个没什么好说的，直接写了个脚本开了5个并发进程把数据分别写到1~100这100个文件中。</p>
<h2 id="修改数据库配置">修改数据库配置</h2>
<p>后面就是InnoDB的天下了，MyISAM从此退出江湖，所以要修改下buffer。另外加大max_allowed_packet是怕有的单个outfile文件的value过大，以防万一（刚好前几天因为max_allowed_packet设置的问题导致一个数据库恢复测试失败，这次还是小心为上）。</p>
<h2 id="数据导入">数据导入</h2>
<p>也没什么好说的，一样写个脚本开了5个并发进程在写数据，可以关闭binlog加速数据加载。需要一说的的是新表多了一个自增ID，因此load的时候需要把新表除了新ID以外的所有字段名写上，费了点功夫。</p>
<p><img src="http://image-myrock-github-io.qiniudn.com/load_data_vs.jpg" alt=""></p>
<h1 id="总结">总结</h1>
<p>这个discuz数据库的帖子表总共约72G+的数据文件+索引文件，约一亿四千万行数据，我们分四个数据库节点并行操作，预计需要花近3个小时才能完成分表操作（不包含前期准备/备份，后期测试等等部分耗时）。<br>中间主要是通过tmpfs加速导出，并行执行加速导出导入操作，最终结果尚可接受，但还存在优化空间。</p>
<h1 id="后续">后续</h1>
<p>后续还有一些需要验证测试的有：</p>
<ol>
<li>MyISAM的ddl以及update能否通过哪些参数设置优化？</li>
<li>InnoDB的ddl以及update能否通过哪些参数设置优化？</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="背景">背景</h1>
<p>相信很多用discuz搭建论坛服务的同学都有这个体验，整个数据库表都是MyISAM引擎，一旦帖子数量到一定量级的时候神马操作都是巨慢无比（MyISAM的各种缺点这里暂且不提）。以此为背景，我们打算对discuz论坛进行改版，简单说来就是彻底抛弃原有的归档功能直接分100张表，按照帖子ID取模分发数据，然后把新表都改成InnoDB引擎。</p>
<p>以这件事为背景，对这次升级过程中数据库的操作做一个记录以及简单分析。抛开前期准备，后期处理等等步骤，这里我们就说下中间的重要环节。</p>
<blockquote>
<p>1.在帖子表里面新增一个字段，且加一条索引<br>2.更新新增字段的值为：mod(tid,100)+1<br>3.创建一个tempfs分区（需要比帖子表.MYD文件大）<br>4.使用select into oufile并发导出数据<br>5.增大innodb_buffer_pool_size,max_allowed_packet，缩小key_buffer_size<br>6.使用load data infile并发导入数据</p>
</blockquote>
<p>中间的数据分表的核心步骤大概就是这么几步，下来我们逐一来讲。</p>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL SQL优化系列]之in与range查询]]></title>
    <link href="http://hidba.ga/2014/09/24/in-and-range/"/>
    <id>http://hidba.ga/2014/09/24/in-and-range/</id>
    <published>2014-09-24T07:22:01.000Z</published>
    <updated>2014-11-07T07:04:16.000Z</updated>
    <content type="html"><![CDATA[<p>首先我们来说下in()这种方式的查询。在《高性能MySQL》里面提及用in这种方式可以有效的替代一定的range查询，提升查询效率，因为在一条索引里面，range字段后面的部分是不生效的。使用in这种方式其实MySQL优化器是转化成了n*m种组合方式来进行查询，最终将返回值合并，有点类似union但是更高效。同时它存在这一些问题：</p>
<blockquote>
<p>老版本的MySQL在IN()组合条件过多的时候会发生很多问题。查询优化可能需要花很多时间，并消耗大量内存。新版本MySQL在组合数超过一定的数量就不进行计划评估了，这可能导致MySQL不能很好的利用索引。</p>
</blockquote>
<p>这里的“一定数量”在MySQL5.6.5以及以后的版本中是由eq_range_index_dive_limit这个参数控制（感谢<a href="http://imysql.com" target="_blank" rel="external">@叶金荣</a>同学的指点）。默认设置是10，一直到5.7以后的版本默认会修改成200，当然我们是可以手动设置的。我们看下5.6手册中的说明：</p>
<blockquote>
<p>The eq_range_index_dive_limit system variable enables you to configure the number of values at which the optimizer switches from one row estimation strategy to the other. To disable use of statistics and always use index dives, set eq_range_index_dive_limit to 0. To permit use of index dives for comparisons of up to N equality ranges, set eq_range_index_dive_limit to N + 1.<br>eq_range_index_dive_limit is available as of MySQL 5.6.5. Before 5.6.5, the optimizer uses index dives, which is equivalent to eq_range_index_dive_limit=0.</p>
</blockquote>
<p>也就是说：</p>
<pre><code><span class="number">1</span>. eq_range_index_dive_limit = <span class="number">0</span> 只能使用<span class="built_in">index</span> dive
<span class="number">2</span>. <span class="number">0</span> &lt; eq_range_index_dive_limit &lt;= <span class="keyword">N</span> 使用<span class="built_in">index</span> statistics
<span class="number">3</span>. eq_range_index_dive_limit &gt; <span class="keyword">N</span> 只能使用<span class="built_in">index</span> dive
</code></pre><p>index dive与index statistics是MySQL优化器对开销代价的估算方法，前者统计速度慢但是能得到精准的值，后者统计速度快但是数据未必精准。</p>
<blockquote>
<p>the optimizer can estimate the row count for each range using dives into the index or index statistics.</p>
</blockquote>
<p>在MySQL5.7版本中将默认值从10修改成200目的是为了尽可能的保证范围等值运算（IN()）执行计划尽量精准，因为IN()list的数量很多时候都是超过10的。</p>
<h2 id="说在前面">说在前面</h2>
<p>今天文章的主题有两个：</p>
<ol>
<li>range查询与索引使用</li>
<li>eq_range_index_dive_limit的说明</li>
</ol>
<a id="more"></a>

<h2 id="range查询与索引使用">range查询与索引使用</h2>
<p>SQL如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pre_forum_post <span class="keyword">WHERE</span> tid=<span class="number">7932552</span> <span class="keyword">AND</span> <span class="string">`invisible`</span> <span class="keyword">IN</span>(<span class="string">'0'</span>,<span class="string">'-2'</span>) </span></div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> dateline <span class="keyword">DESC</span>  <span class="keyword">LIMIT</span> <span class="number">10</span>;</div></pre></td></tr></table></figure>

<p>索引如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+----------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</div><div class="line">| <span class="class">Table</span>          | <span class="class">Non_unique</span> | <span class="class">Key_name</span>     | <span class="class">Seq_in_index</span> | <span class="class">Column_name</span> | <span class="class">Collation</span> | <span class="class">Cardinality</span> | <span class="class">Sub_part</span> | <span class="class">Packed</span> | <span class="class">Null</span> | <span class="class">Index_type</span> | <span class="class">Comment</span> | <span class="class">Index_comment</span> |</div><div class="line">+----------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">0</span> | <span class="class">PRIMARY</span>      |            <span class="number">1</span> <span class="localvars">| tid         |</span> <span class="class">A</span>         |        <span class="class">NULL</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">0</span> | <span class="class">PRIMARY</span>      |            <span class="number">2</span> <span class="localvars">| position    |</span> <span class="class">A</span>         |    <span class="number">25521392</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">0</span> <span class="localvars">| pid          |</span>            <span class="number">1</span> <span class="localvars">| pid         |</span> <span class="class">A</span>         |    <span class="number">25521392</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| fid          |</span>            <span class="number">1</span> <span class="localvars">| fid         |</span> <span class="class">A</span>         |        <span class="number">1490</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| displayorder |</span>            <span class="number">1</span> <span class="localvars">| tid         |</span> <span class="class">A</span>         |      <span class="number">880048</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| displayorder |</span>            <span class="number">2</span> <span class="localvars">| invisible   |</span> <span class="class">A</span>         |      <span class="number">945236</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| displayorder |</span>            <span class="number">3</span> <span class="localvars">| dateline    |</span> <span class="class">A</span>         |    <span class="number">25521392</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| first        |</span>            <span class="number">1</span> <span class="localvars">| tid         |</span> <span class="class">A</span>         |      <span class="number">880048</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| first        |</span>            <span class="number">2</span> <span class="localvars">| first       |</span> <span class="class">A</span>         |     <span class="number">1215304</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| new_auth     |</span>            <span class="number">1</span> <span class="localvars">| authorid    |</span> <span class="class">A</span>         |     <span class="number">1963184</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| new_auth     |</span>            <span class="number">2</span> <span class="localvars">| invisible   |</span> <span class="class">A</span>         |     <span class="number">1963184</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| new_auth     |</span>            <span class="number">3</span> <span class="localvars">| tid         |</span> <span class="class">A</span>         |    <span class="number">12760696</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| idx_dt       |</span>            <span class="number">1</span> <span class="localvars">| dateline    |</span> <span class="class">A</span>         |    <span class="number">25521392</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| mul_test     |</span>            <span class="number">1</span> <span class="localvars">| tid         |</span> <span class="class">A</span>         |      <span class="number">880048</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| mul_test     |</span>            <span class="number">2</span> <span class="localvars">| invisible   |</span> <span class="class">A</span>         |      <span class="number">945236</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| mul_test     |</span>            <span class="number">3</span> <span class="localvars">| dateline    |</span> <span class="class">A</span>         |    <span class="number">25521392</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line"><span class="localvars">| pre_forum_post |</span>          <span class="number">1</span> <span class="localvars">| mul_test     |</span>            <span class="number">4</span> <span class="localvars">| pid         |</span> <span class="class">A</span>         |    <span class="number">25521392</span> |     <span class="class">NULL</span> | <span class="class">NULL</span>   |      | <span class="class">BTREE</span>      |         |               | </div><div class="line">+----------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</div></pre></td></tr></table></figure>

<p>看下执行计划：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@localhost 16:08:27 [ultrax]&gt; explain SELECT  * FROM pre<span class="emphasis">_forum_</span>post WHERE tid=7932552 AND <span class="smartquote">`invisible` IN('</span>0',<span class="emphasis">'-2'</span>) </div><div class="line"><span class="header">    -&gt; ORDER BY dateline DESC  LIMIT 10;</span></div><div class="line">+----+-------------+----------------+-------+-------------------------------------------+--------------+---------+------+------+---------------------------------------+</div><div class="line"><span class="header">| id | select_type | table          | type  | possible_keys                             | key          | key_len | ref  | rows | Extra                                 |</span></div><div class="line">+----+-------------+----------------+-------+-------------------------------------------+--------------+---------+------+------+---------------------------------------+</div><div class="line"><span class="header">|  1 | SIMPLE      | pre_forum_post | range | PRIMARY,displayorder,first,mul_test,idx_1 | displayorder | 4       | NULL |   54 | Using index condition; Using filesort | </span></div><div class="line">+----+-------------+----------------+-------+-------------------------------------------+--------------+---------+------+------+---------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>MySQL优化器认为这是一个range查询，那么(tid,invisible,dateline)这条索引中，dateline字段肯定用不上了，也就是说这个SQL最后的排序肯定会生成一个临时结果集，然后再结果集里面完成排序，而不是直接在索引中直接完成排序动作，于是我们尝试增加了一条索引。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">root@localhost <span class="number">16</span>:<span class="number">09</span>:<span class="number">06</span> [ultrax]&gt; alter table pre_forum_post <span class="keyword">add</span> <span class="keyword">index</span> idx_1 (tid,dateline);   </div><div class="line">Query OK, <span class="number">20374596</span> rows affected, <span class="number">0</span> warning (<span class="number">600.23</span> sec)</div><div class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></div><div class="line"></div><div class="line">root@localhost <span class="number">16</span>:<span class="number">20</span>:<span class="number">22</span> [ultrax]&gt; explain <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pre_forum_post force <span class="keyword">index</span> (idx_1) <span class="keyword">WHERE</span> tid=<span class="number">7932552</span> <span class="keyword">AND</span> `invisible` <span class="keyword">IN</span>(<span class="string">'0'</span>,<span class="string">'-2'</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> dateline <span class="keyword">DESC</span>  LIMIT <span class="number">10</span>;</div><div class="line">+----+-------------+----------------+------+---------------+-------+---------+-------+--------+-------------+</div><div class="line">| id | select_type | table          | <span class="keyword">type</span> | possible_keys | key   | key_len | ref   | rows   | Extra       |</div><div class="line">+----+-------------+----------------+------+---------------+-------+---------+-------+--------+-------------+</div><div class="line">|  <span class="number">1</span> | SIMPLE      | pre_forum_post | ref  | idx_1         | idx_1 | <span class="number">3</span>       | <span class="keyword">const</span> | <span class="number">120646</span> | <span class="keyword">Using</span> <span class="keyword">where</span> | </div><div class="line">+----+-------------+----------------+------+---------------+-------+---------+-------+--------+-------------+</div><div class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line">root@localhost <span class="number">16</span>:<span class="number">22</span>:<span class="number">06</span> [ultrax]&gt; <span class="keyword">SELECT</span> sql_no_cache * <span class="keyword">FROM</span> pre_forum_post <span class="keyword">WHERE</span> tid=<span class="number">7932552</span> <span class="keyword">AND</span> `invisible` <span class="keyword">IN</span>(<span class="string">'0'</span>,<span class="string">'-2'</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> dateline <span class="keyword">DESC</span>  LIMIT <span class="number">10</span>;</div><div class="line">...</div><div class="line"><span class="number">10</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.40</span> sec)</div><div class="line"></div><div class="line">root@localhost <span class="number">16</span>:<span class="number">23</span>:<span class="number">55</span> [ultrax]&gt; <span class="keyword">SELECT</span> sql_no_cache * <span class="keyword">FROM</span> pre_forum_post force <span class="keyword">index</span> (idx_1) <span class="keyword">WHERE</span> tid=<span class="number">7932552</span> <span class="keyword">AND</span> `invisible` <span class="keyword">IN</span>(<span class="string">'0'</span>,<span class="string">'-2'</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> dateline <span class="keyword">DESC</span>  LIMIT <span class="number">10</span>;</div><div class="line">...</div><div class="line"><span class="number">10</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure>

<p>实验证明效果是极好的，其实不难理解，上面我们就说了in()在MySQL优化器里面是以多种组合方式来检索数据的，如果加了一个排序或者分组那势必只能在临时结果集上操作，也就是说索引里面即使包含了排序或者分组的字段依然是没用的。唯一不满的是MySQL优化器的选择依然不够靠谱。</p>
<p>总结下：<strong>在MySQL查询里面使用in()，除了要注意in()list的数量以及eq_range_index_dive_limit的值以外（具体见下），还要注意如果SQL包含排序/分组/去重等等就需要注意索引的使用</strong>。</p>
<h2 id="eq_range_index_dive_limit的说明">eq_range_index_dive_limit的说明</h2>
<p>还是上面的案例，为什么idx_1无法直接使用？需要使用hint强制只用这个索引呢？这里我们首先看下eq_range_index_dive_limit的值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@localhost 22:38:05 [ultrax]&gt; show variables like <span class="emphasis">'eq_range_index_dive_limit'</span>;</div><div class="line"><span class="code">+---------------------------+</span>-------+</div><div class="line"><span class="header">| Variable_name             | Value |</span></div><div class="line">+---------------------------+-------+</div><div class="line"><span class="header">| eq_range_index_dive_limit | 2     | </span></div><div class="line">+---------------------------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>根据我们上面说的这种情况<strong>0 &lt; eq_range_index_dive_limit &lt;= N使用index statistics</strong>，那么接下来我们用OPTIMIZER_TRACE来一看究竟。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  <span class="string">"index"</span>: <span class="string">"displayorder"</span>,</div><div class="line">  <span class="string">"ranges"</span>: [</div><div class="line">    <span class="string">"7932552 &lt;= tid &lt;= 7932552 AND -2 &lt;= invisible &lt;= -2"</span>,</div><div class="line">    <span class="string">"7932552 &lt;= tid &lt;= 7932552 AND 0 &lt;= invisible &lt;= 0"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"rowid_ordered"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"index_only"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"rows"</span>: <span class="number">54</span>,</div><div class="line">  <span class="string">"cost"</span>: <span class="number">66.81</span>,</div><div class="line">  <span class="string">"chosen"</span>: <span class="literal">true</span></div><div class="line">}</div><div class="line">// index dive为<span class="literal">false</span>，最终chosen是<span class="literal">true</span></div><div class="line">...</div><div class="line">{</div><div class="line">  <span class="string">"index"</span>: <span class="string">"idx_1"</span>,</div><div class="line">  <span class="string">"ranges"</span>: [</div><div class="line">    <span class="string">"7932552 &lt;= tid &lt;= 7932552"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"rowid_ordered"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"index_only"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"rows"</span>: <span class="number">120646</span>,</div><div class="line">  <span class="string">"cost"</span>: <span class="number">144776</span>,</div><div class="line">  <span class="string">"chosen"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"cause"</span>: <span class="string">"cost"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以看到displayorder索引的cost是66.81，而idx_1的cost是120646，而最终MySQL优化器选择了displayorder这条索引。那么如果我们把eq_range_index_dive_limit设置&gt;N是不是应该就会使用index dive计算方式，得到更准确的执行计划呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@localhost 22:52:52 [ultrax]&gt; set  eq<span class="emphasis">_range_</span>index<span class="emphasis">_dive_</span>limit = 3;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line">root@localhost 22:55:38 [ultrax]&gt; explain SELECT * FROM pre<span class="emphasis">_forum_</span>post WHERE tid=7932552 AND <span class="smartquote">`invisible` IN('</span>0',<span class="emphasis">'-2'</span>) ORDER BY dateline DESC  LIMIT 10;</div><div class="line"><span class="code">+----+</span>-------------<span class="code">+----------------+</span>------<span class="code">+-------------------------------------------+</span>-------<span class="code">+---------+</span>-------<span class="code">+--------+</span>-------------+</div><div class="line"><span class="header">| id | select_type | table          | type | possible_keys                             | key   | key_len | ref   | rows   | Extra       |</span></div><div class="line">+----+-------------+----------------+------+-------------------------------------------+-------+---------+-------+--------+-------------+</div><div class="line"><span class="header">|  1 | SIMPLE      | pre_forum_post | ref  | PRIMARY,displayorder,first,mul_test,idx_1 | idx_1 | 3       | const | 120646 | Using where | </span></div><div class="line">+----+-------------+----------------+------+-------------------------------------------+-------+---------+-------+--------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>optimize_trace结果如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  <span class="string">"index"</span>: <span class="string">"displayorder"</span>,</div><div class="line">  <span class="string">"ranges"</span>: [</div><div class="line">    <span class="string">"7932552 &lt;= tid &lt;= 7932552 AND -2 &lt;= invisible &lt;= -2"</span>,</div><div class="line">    <span class="string">"7932552 &lt;= tid &lt;= 7932552 AND 0 &lt;= invisible &lt;= 0"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"index_dives_for_eq_ranges"</span>: true,</div><div class="line">  <span class="string">"rowid_ordered"</span>: false,</div><div class="line">  <span class="string">"using_mrr"</span>: false,</div><div class="line">  <span class="string">"index_only"</span>: false,</div><div class="line">  <span class="string">"rows"</span>: <span class="number">188193</span>,</div><div class="line">  <span class="string">"cost"</span>: <span class="number">225834</span>,</div><div class="line">  <span class="string">"chosen"</span>: true</div><div class="line">}</div><div class="line"><span class="keyword">...</span></div><div class="line">{</div><div class="line">  <span class="string">"index"</span>: <span class="string">"idx_1"</span>,</div><div class="line">  <span class="string">"ranges"</span>: [</div><div class="line">    <span class="string">"7932552 &lt;= tid &lt;= 7932552"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"index_dives_for_eq_ranges"</span>: true,</div><div class="line">  <span class="string">"rowid_ordered"</span>: false,</div><div class="line">  <span class="string">"using_mrr"</span>: false,</div><div class="line">  <span class="string">"index_only"</span>: false,</div><div class="line">  <span class="string">"rows"</span>: <span class="number">120646</span>,</div><div class="line">  <span class="string">"cost"</span>: <span class="number">144776</span>,</div><div class="line">  <span class="string">"chosen"</span>: true</div><div class="line">}</div><div class="line"><span class="keyword">...</span></div><div class="line">  <span class="string">"cost_for_plan"</span>: <span class="number">144775</span>,</div><div class="line">  <span class="string">"rows_for_plan"</span>: <span class="number">120646</span>,</div><div class="line">  <span class="string">"chosen"</span>: true</div><div class="line">// 在备选索引选择中两条索引都被选择，在最后的逻辑优化中选在了代价最小的索引也就是idx_1</div></pre></td></tr></table></figure>

<p>以上就是在等值范围查询中eq_range_index_dive_limit的值怎么影响MySQL优化器计算开销，从而影响索引的选择。另外我们可以通过profiling来看看优化器的统计耗时：</p>
<p><strong>index dive</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+----------------------+----------+</div><div class="line">| <span class="class">Status</span>               | <span class="class">Duration</span> |</div><div class="line">+----------------------+----------+</div><div class="line"><span class="localvars">| starting             |</span> <span class="number">0.000048</span> | </div><div class="line"><span class="localvars">| checking permissions |</span> <span class="number">0.000004</span> | </div><div class="line">| <span class="class">Opening</span> tables       | <span class="number">0.000015</span> | </div><div class="line"><span class="localvars">| init                 |</span> <span class="number">0.000044</span> | </div><div class="line">| <span class="class">System</span> lock          | <span class="number">0.000009</span> | </div><div class="line"><span class="localvars">| optimizing           |</span> <span class="number">0.000014</span> | </div><div class="line"><span class="localvars">| statistics           |</span> <span class="number">0.032089</span> | </div><div class="line"><span class="localvars">| preparing            |</span> <span class="number">0.000022</span> | </div><div class="line">| <span class="class">Sorting</span> result       | <span class="number">0.000003</span> | </div><div class="line"><span class="localvars">| executing            |</span> <span class="number">0.000003</span> | </div><div class="line">| <span class="class">Sending</span> data         | <span class="number">0.000101</span> | </div><div class="line"><span class="localvars">| end                  |</span> <span class="number">0.000004</span> | </div><div class="line"><span class="localvars">| query end            |</span> <span class="number">0.000002</span> | </div><div class="line"><span class="localvars">| closing tables       |</span> <span class="number">0.000009</span> | </div><div class="line"><span class="localvars">| freeing items        |</span> <span class="number">0.000013</span> | </div><div class="line"><span class="localvars">| cleaning up          |</span> <span class="number">0.000012</span> | </div><div class="line">+----------------------+----------+</div></pre></td></tr></table></figure>

<p><strong>index statistics</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+----------------------+----------+</div><div class="line">| <span class="class">Status</span>               | <span class="class">Duration</span> |</div><div class="line">+----------------------+----------+</div><div class="line"><span class="localvars">| starting             |</span> <span class="number">0.000045</span> | </div><div class="line"><span class="localvars">| checking permissions |</span> <span class="number">0.000003</span> | </div><div class="line">| <span class="class">Opening</span> tables       | <span class="number">0.000014</span> | </div><div class="line"><span class="localvars">| init                 |</span> <span class="number">0.000040</span> | </div><div class="line">| <span class="class">System</span> lock          | <span class="number">0.000008</span> | </div><div class="line"><span class="localvars">| optimizing           |</span> <span class="number">0.000014</span> | </div><div class="line"><span class="localvars">| statistics           |</span> <span class="number">0.000086</span> | </div><div class="line"><span class="localvars">| preparing            |</span> <span class="number">0.000016</span> | </div><div class="line">| <span class="class">Sorting</span> result       | <span class="number">0.000002</span> | </div><div class="line"><span class="localvars">| executing            |</span> <span class="number">0.000002</span> | </div><div class="line">| <span class="class">Sending</span> data         | <span class="number">0.000016</span> | </div><div class="line">| <span class="class">Creating</span> sort index  | <span class="number">0.412123</span> | </div><div class="line"><span class="localvars">| end                  |</span> <span class="number">0.000012</span> | </div><div class="line"><span class="localvars">| query end            |</span> <span class="number">0.000004</span> | </div><div class="line"><span class="localvars">| closing tables       |</span> <span class="number">0.000013</span> | </div><div class="line"><span class="localvars">| freeing items        |</span> <span class="number">0.000023</span> | </div><div class="line"><span class="localvars">| cleaning up          |</span> <span class="number">0.000015</span> | </div><div class="line">+----------------------+----------+</div></pre></td></tr></table></figure>

<p>可以看到当eq_range_index_dive_limit加大使用index dive时，优化器统计耗时明显比ndex statistics方式来的长，但最终它使用了作出了更合理的执行计划。统计耗时0.032089s vs .000086s，但是SQL执行耗时却是约0.03s vs 0.41s。</p>
<h2 id="附：如何使用optimize_trace">附：如何使用optimize_trace</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">set</span> optimizer_trace=<span class="string">'enabled=on'</span>;</span>  </div><div class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.optimizer_trace\G</span></div><div class="line">// 注：optimizer_trace建议只在<span class="keyword">session</span>模式下开启调试即可</div></pre></td></tr></table></figure>

<p><strong>参考资料</strong><br><a href="http://dev.mysql.com/doc/refman/5.6/en/range-optimization.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.6/en/range-optimization.html</a><br><a href="http://imysql.com/2014/08/05/a-fake-bug-with-eq-range-index-dive-limit.shtml" target="_blank" rel="external">http://imysql.com/2014/08/05/a-fake-bug-with-eq-range-index-dive-limit.shtml</a><br><a href="http://blog.163.com/li_hx/blog/static/18399141320147521735442/" target="_blank" rel="external">http://blog.163.com/li_hx/blog/static/18399141320147521735442/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先我们来说下in()这种方式的查询。在《高性能MySQL》里面提及用in这种方式可以有效的替代一定的range查询，提升查询效率，因为在一条索引里面，range字段后面的部分是不生效的。使用in这种方式其实MySQL优化器是转化成了n*m种组合方式来进行查询，最终将返回值合并，有点类似union但是更高效。同时它存在这一些问题：</p>
<blockquote>
<p>老版本的MySQL在IN()组合条件过多的时候会发生很多问题。查询优化可能需要花很多时间，并消耗大量内存。新版本MySQL在组合数超过一定的数量就不进行计划评估了，这可能导致MySQL不能很好的利用索引。</p>
</blockquote>
<p>这里的“一定数量”在MySQL5.6.5以及以后的版本中是由eq_range_index_dive_limit这个参数控制（感谢<a href="http://imysql.com" target="_blank" rel="external">@叶金荣</a>同学的指点）。默认设置是10，一直到5.7以后的版本默认会修改成200，当然我们是可以手动设置的。我们看下5.6手册中的说明：</p>
<blockquote>
<p>The eq_range_index_dive_limit system variable enables you to configure the number of values at which the optimizer switches from one row estimation strategy to the other. To disable use of statistics and always use index dives, set eq_range_index_dive_limit to 0. To permit use of index dives for comparisons of up to N equality ranges, set eq_range_index_dive_limit to N + 1.<br>eq_range_index_dive_limit is available as of MySQL 5.6.5. Before 5.6.5, the optimizer uses index dives, which is equivalent to eq_range_index_dive_limit=0.</p>
</blockquote>
<p>也就是说：</p>
<pre><code><span class="number">1</span>. eq_range_index_dive_limit = <span class="number">0</span> 只能使用<span class="built_in">index</span> dive
<span class="number">2</span>. <span class="number">0</span> &lt; eq_range_index_dive_limit &lt;= <span class="keyword">N</span> 使用<span class="built_in">index</span> statistics
<span class="number">3</span>. eq_range_index_dive_limit &gt; <span class="keyword">N</span> 只能使用<span class="built_in">index</span> dive
</code></pre><p>index dive与index statistics是MySQL优化器对开销代价的估算方法，前者统计速度慢但是能得到精准的值，后者统计速度快但是数据未必精准。</p>
<blockquote>
<p>the optimizer can estimate the row count for each range using dives into the index or index statistics.</p>
</blockquote>
<p>在MySQL5.7版本中将默认值从10修改成200目的是为了尽可能的保证范围等值运算（IN()）执行计划尽量精准，因为IN()list的数量很多时候都是超过10的。</p>
<h2 id="说在前面">说在前面</h2>
<p>今天文章的主题有两个：</p>
<ol>
<li>range查询与索引使用</li>
<li>eq_range_index_dive_limit的说明</li>
</ol>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
      <category term="SQL优化" scheme="http://hidba.ga/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL案例]之恢复进程莫名被杀]]></title>
    <link href="http://hidba.ga/2014/09/22/recover-be-killed/"/>
    <id>http://hidba.ga/2014/09/22/recover-be-killed/</id>
    <published>2014-09-22T03:23:12.000Z</published>
    <updated>2014-11-07T07:04:30.000Z</updated>
    <content type="html"><![CDATA[<p>今天上班就发现一起数据库例行恢复作业失败，失败提示为：“数据库恢复失败”，也就是说是在执行mysql &lt; dumpfile的时候失败了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ root@localhost ]#<span class="regexp">/usr/</span>local<span class="regexp">/mysql56/</span>bin<span class="regexp">/mysql -S ./m</span>ysql.sock bi_monitor &lt; <span class="regexp">/home/m</span>ysql<span class="regexp">/backup/</span><span class="number">2014</span>-<span class="number">09</span>-<span class="number">21</span>_bi_monitor_3346.sql </div><div class="line">ERROR <span class="number">2006</span> (HY000) at line <span class="number">294</span>: MySQL server has gone away</div></pre></td></tr></table></figure>

<p>MySQL server has gone away是指客户端与MySQL服务端之间的连接段开，一般来说原因有这么几个：</p>
<ol>
<li>MySQL crash：MySQL Server宕机</li>
<li>connection timeout：客户端连接超时</li>
<li>kill connection：连接进程被杀，与connection timeout差不多，区别在于一个是MySQL Server主动，一个是被动</li>
<li>max_allowed_packet too small：返回结果集大于max_allowed_packet限制</li>
</ol>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show global status like 'uptime';</span></div><div class="line">+---------------+------------+</div><div class="line"><span class="header">| Variable_name | Value      |</span></div><div class="line">+---------------+------------+</div><div class="line"><span class="header">| Uptime        | 230493834  | </span></div><div class="line">+---------------+------------+</div><div class="line"></div><div class="line"><span class="header">mysql&gt; show global variables like '%timeout%';</span></div><div class="line">+-----------------------------+----------+</div><div class="line"><span class="header">| Variable_name               | Value    |</span></div><div class="line">+-----------------------------+----------+</div><div class="line">| interactive<span class="emphasis">_timeout         | 28800    | </span></div><div class="line">| wait_timeout                | 28800    | </div><div class="line"><span class="code">+-----------------------------+</span>----------+</div><div class="line"></div><div class="line"><span class="header">mysql&gt; show global status like 'com_kill';         </span></div><div class="line">+---------------+-------+</div><div class="line"><span class="header">| Variable_name | Value |</span></div><div class="line">+---------------+-------+</div><div class="line"><span class="header">| Com_kill      | 0     | </span></div><div class="line">+---------------+-------+</div></pre></td></tr></table></figure>

<p>由此看来原因1、2、3都不是造成这次失败的原因了，那应该就是原因4了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show global variables like 'max_allowed_packet';</span></div><div class="line">+--------------------+-------+</div><div class="line"><span class="header">| Variable_name      | Value |</span></div><div class="line">+--------------------+-------+</div><div class="line"><span class="header">| max_allowed_packet | 1024  | </span></div><div class="line">+--------------------+-------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; set global max<span class="emphasis">_allowed_</span>packet=1024*1024*1024;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div></pre></td></tr></table></figure>

<p>再导入测试，果然顺利结束不会报错了。再深入验证下果然这个备份文件的value超大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天上班就发现一起数据库例行恢复作业失败，失败提示为：“数据库恢复失败”，也就是说是在执行mysql &lt; dumpfile的时候失败了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ root@localhost ]#<span class="regexp">/usr/</span>local<span class="regexp">/mysql56/</span>bin<span class="regexp">/mysql -S ./m</span>ysql.sock bi_monitor &lt; <span class="regexp">/home/m</span>ysql<span class="regexp">/backup/</span><span class="number">2014</span>-<span class="number">09</span>-<span class="number">21</span>_bi_monitor_3346.sql </div><div class="line">ERROR <span class="number">2006</span> (HY000) at line <span class="number">294</span>: MySQL server has gone away</div></pre></td></tr></table></figure>

<p>MySQL server has gone away是指客户端与MySQL服务端之间的连接段开，一般来说原因有这么几个：</p>
<ol>
<li>MySQL crash：MySQL Server宕机</li>
<li>connection timeout：客户端连接超时</li>
<li>kill connection：连接进程被杀，与connection timeout差不多，区别在于一个是MySQL Server主动，一个是被动</li>
<li>max_allowed_packet too small：返回结果集大于max_allowed_packet限制</li>
</ol>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[MySQL案例]之一把看不见的锁]]></title>
    <link href="http://hidba.ga/2014/09/20/a-invisible-lock/"/>
    <id>http://hidba.ga/2014/09/20/a-invisible-lock/</id>
    <published>2014-09-20T15:52:51.000Z</published>
    <updated>2014-11-07T07:04:10.000Z</updated>
    <content type="html"><![CDATA[<p>昨晚半夜处理了一个故障，只是简单SQL执行缺少索引导致CPU飙高，加一条索引就搞定。原来以为事情到此为止，让另外一个同事收尾准备睡觉了，这个时候高潮出现了。刚才处理的是一台slave server，为了保证实例数据对象一致性，让同事先删掉，然后在master server再加这条索引，最后发现add index的操作在slave server一直在等metadata lock释放了，并且在processlist里面居然找不到任何引起表锁的请求。就这样折腾了到凌晨，后面索性就丢在自己等锁释放，差不多过了6分钟创建成功，load再次下降。</p>
<h3 id="分析">分析</h3>
<p>事后在5.5的手册中找到了解释：</p>
<blockquote>
<p>To ensure transaction serializability, the server must not permit one session to perform a data definition language (DDL) statement on a table that is used in an uncompleted transaction in another session. The server achieves this by acquiring metadata locks on tables used within a transaction and deferring release of those locks until the transaction ends. A metadata lock on a table prevents changes to the table’s structure. This locking approach has the implication that a table that is being used by a transaction within one session cannot be used in DDL statements by other sessions until the transaction ends. </p>
</blockquote>
<a id="more"></a>

<p>如此一来我们就知道原来是有事务堵塞DDL操作，但是回忆昨晚的操作，我曾经把所有非Sleep的session都杀掉，但是锁依然没有释放，除非是那些Sleep的session在作怪，想想还真有可能。<br>这里我们做个试验测试下：</p>
<p><strong>A session关闭自动提交，做一个简单的查询后，不主动提交事务。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; set autocommit=0;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line"><span class="header">mysql&gt; select * from t where id = 8;</span></div><div class="line">+------+------+-------+-------+-------+-------+-------+</div><div class="line"><span class="header">| id   | name | name1 | name2 | name3 | name4 | name5 |</span></div><div class="line">+------+------+-------+-------+-------+-------+-------+</div><div class="line"><span class="header">|    8 | NULL | NULL  | NULL  | NULL  | NULL  | NULL  |</span></div><div class="line">+------+------+-------+-------+-------+-------+-------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt;</div></pre></td></tr></table></figure>

<p><strong>B session做一个DDL操作，这时候被堵塞了。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table t add index idx_1 (id);</div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p><strong>C session查看MySQL进程表，发现session B被堵塞，session A处于Sleep状态，这样根本看不到任何引起表锁的请求。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="header">mysql&gt; show processlist;</span></div><div class="line">+------+-----------------+-----------+------+---------+---------+---------------------------------+------------------------------------+-----------+---------------+-----------+</div><div class="line"><span class="header">| Id   | User            | Host      | db   | Command | Time    | State                           | Info                               | Rows_sent | Rows_examined | Rows_read |</span></div><div class="line">+------+-----------------+-----------+------+---------+---------+---------------------------------+------------------------------------+-----------+---------------+-----------+</div><div class="line">|    1 | event<span class="emphasis">_scheduler | localhost | NULL | Daemon  | 5286457 | Waiting on empty queue          | NULL                               |         0 |             0 |         1 | </span></div><div class="line">| 3127 | root            | localhost | test | Query   |      16 | Waiting for table metadata lock | alter table t add index idx_1 (id) |         0 |             0 |         1 | </div><div class="line">| 3133 | root            | localhost | test | Sleep   |      45 |                                 | NULL                               |         1 |             9 |        10 | </div><div class="line"><span class="header">| 3134 | root            | localhost | test | Query   |       0 | NULL                            | show processlist                   |         0 |             0 |         3 | </span></div><div class="line">+------+-----------------+-----------+------+---------+---------+---------------------------------+------------------------------------+-----------+---------------+-----------+</div><div class="line">4 rows in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>为了验证当时数据库是不是就是这样引起DDL的堵塞，我大致抓取了十几秒钟的general_log，果然发现了大量的set autocommit=x/commit的操作，不出意外就是这些processlist看不到的进程堵塞了DDL。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ root@localhost ]#cat general_log |grep <span class="operator"><span class="keyword">commit</span> |cut -f <span class="number">4</span> |sort |uniq -c</span></div><div class="line">    <span class="number">197</span> <span class="keyword">commit</span></div><div class="line">    <span class="number">186</span> <span class="keyword">SET</span> autocommit=<span class="number">0</span></div><div class="line">    <span class="number">393</span> <span class="keyword">SET</span> autocommit=<span class="number">1</span></div></pre></td></tr></table></figure>

<h3 id="怎么快速发现锁的元凶">怎么快速发现锁的元凶</h3>
<p>通过上面的实验我们证实了是因为未提交的事务引起metadata lock，但是怎么快速发现元凶并解决它呢？</p>
<p><strong>查找InnoDB事务表</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT <span class="keyword">*</span> FROM information_schema.INNODB_TRX\G </div><div class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> 1. row <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></div><div class="line">                    trx_id: 57E651</div><div class="line">                 trx_state: RUNNING</div><div class="line">               trx_started: 2014-09-21 15:10:47</div><div class="line">     trx_requested_lock_id: NULL</div><div class="line">          trx_wait_started: NULL</div><div class="line">                trx_weight: 0</div><div class="line">       trx_mysql_thread_id: 3133</div><div class="line">                 trx_query: NULL</div><div class="line">       trx_operation_state: NULL</div><div class="line">         trx_tables_in_use: 0</div><div class="line">         trx_tables_locked: 0</div><div class="line">          trx_lock_structs: 0</div><div class="line">     trx_lock_memory_bytes: 376</div><div class="line">           trx_rows_locked: 0</div><div class="line">         trx_rows_modified: 0</div><div class="line">   trx_concurrency_tickets: 0</div><div class="line">       trx_isolation_level: REPEATABLE READ</div><div class="line">         trx_unique_checks: 1</div><div class="line">    trx_foreign_key_checks: 1</div><div class="line">trx_last_foreign_key_error: NULL</div><div class="line"> trx_adaptive_hash_latched: 0</div><div class="line"> trx_adaptive_hash_timeout: 10000</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>

<p>通过事务表我们确实快速找到了未提交的事务，但是这只是模拟的测试环境，换成是生产环境中不可能只有一张表，而且存在许多并发的事务，所以通过事务表来查找明显就不现实了。</p>
<p><strong>通过InnoDB的状态监控</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">------------</span></div><div class="line">TRANSACTIONS</div><div class="line"><span class="comment">------------</span></div><div class="line">Trx <span class="property">id</span> counter <span class="number">57E655</span></div><div class="line">Purge done <span class="keyword">for</span> trx's n:o &lt; <span class="number">57E651</span> undo n:o &lt; <span class="number">0</span></div><div class="line">History <span class="type">list</span> <span class="property">length</span> <span class="number">1641</span></div><div class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</div><div class="line"><span class="comment">---TRANSACTION 0, not started</span></div><div class="line">MySQL thread <span class="property">id</span> <span class="number">3134</span>, OS thread handle <span class="number">0x418e4940</span>, query <span class="property">id</span> <span class="number">11413</span> localhost root</div><div class="line">show engine innodb status</div><div class="line"><span class="comment">---TRANSACTION 57E652, not started</span></div><div class="line">mysql tables <span class="keyword">in</span> use <span class="number">1</span>, locked <span class="number">1</span></div><div class="line">MySQL thread <span class="property">id</span> <span class="number">3127</span>, OS thread handle <span class="number">0x412db940</span>, query <span class="property">id</span> <span class="number">11402</span> localhost root Waiting <span class="keyword">for</span> table metadata lock</div><div class="line">alter table t add index idx_1 (<span class="property">id</span>)</div><div class="line"><span class="comment">---TRANSACTION 57E651, ACTIVE 426 sec</span></div><div class="line">MySQL thread <span class="property">id</span> <span class="number">3133</span>, OS thread handle <span class="number">0x41946940</span>, query <span class="property">id</span> <span class="number">11401</span> localhost root</div><div class="line">Trx <span class="command">read</span> view will <span class="keyword">not</span> see trx <span class="keyword">with</span> <span class="property">id</span> &gt;= <span class="number">57E652</span>, sees &lt; <span class="number">57E652</span></div></pre></td></tr></table></figure>

<p>上面是InnoDB status输出的事务信息（用innodb_lock_monitor来调试，发现输出是一样的，可能5.5以后的版本show engine innodb status包含了所有的信息输出了吧），从上面信息我们可以看到线程3217被锁住，但是依然找不到锁的根源，上面只有看到一个活跃的线程3133，或许我们可以推断出来。但是换成生产环境，这又不现实了。</p>
<p>这里我们是使用事务控制来模拟锁，如果是在autocommit=1的情况下，直接加一个显示锁呢？那更悲剧了，事务表跟innodb status都看不到任何信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">lock</span> <span class="keyword">table</span> t <span class="keyword">read</span>/<span class="keyword">write</span>;</span></div></pre></td></tr></table></figure>

<p><strong>A session</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">mysql&gt;</span> set autocommit=<span class="number">1</span>;</span></div><div class="line"><span class="constant">Query</span> <span class="constant">OK</span>, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">00</span> sec)</div><div class="line"><span class="input"><span class="prompt"></span></span></div><div class="line">mysql&gt; lock table t read;</div><div class="line"><span class="constant">Query</span> <span class="constant">OK</span>, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">00</span> sec)</div></pre></td></tr></table></figure>

<p><strong>B session</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table t add index idx_4 (id); </div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p><strong>C session</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT <span class="keyword">*</span> FROM information_schema.INNODB_TRX\G </div><div class="line">Empty set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; show engine innodb status\G                   </div><div class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> 1. row <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></div><div class="line">...</div><div class="line">------------</div><div class="line">TRANSACTIONS</div><div class="line">------------</div><div class="line">Trx id counter 57E66B</div><div class="line">Purge done for trx's n:o <span class="variable">&lt; 57E667 undo n:o &lt; 0</span></div><div class="line">History list length 1635</div><div class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</div><div class="line">---TRANSACTION 0, not started</div><div class="line">mysql tables in use 1, locked 1</div><div class="line">MySQL thread id 3138, OS thread handle 0x41915940, query id 11448 localhost root</div><div class="line">---TRANSACTION 0, not started</div><div class="line">MySQL thread id 3137, OS thread handle 0x4181e940, query id 11451 localhost root</div><div class="line">show engine innodb status</div><div class="line">---TRANSACTION 57E668, not started</div><div class="line">mysql tables in use 1, locked 1</div><div class="line">MySQL thread id 3127, OS thread handle 0x412db940, query id 11449 localhost root Waiting for table metadata lock</div><div class="line">alter table t add index idx_4 (id)</div><div class="line">...</div></pre></td></tr></table></figure>

<p>所以说想快速发现锁的根源，好像还是没有快速便捷的方法，还是只能仔细的看事务表或者innodb status输出了，如果你有更好的办法也麻烦告知Orz。</p>
<h3 id="其他总结">其他总结</h3>
<p>在做实验看文档的过程中顺便复习了下锁，MVCC等一些列的知识，顺便记录下：</p>
<ol>
<li>在RR跟RC两种事务隔离级别下，InnoDB支持MVCC，我们可以理解为行级锁的妥协，在很多查询的场景下<strong>不加共享锁</strong>，实现非堵塞读，也就是说这个时候update跟select是不会互斥的（当然根据不同的事务隔离级别，查询出来的值可能是不一样的）。</li>
<li>实验中间自己思维绕进死胡同：支持mvcc的模式下select不堵塞update是因为不加S锁，但是为什么依然堵塞DDL？难道还是有加S锁？后面再想想其实引起DDL堵塞的是metadata lock，其实跟S锁无关，是MySQL为了保证事务客串行性（serializability）所做的限制，而可串行性是并行事务正确性的唯一准则。</li>
<li>在5.6版本以前DDL加的是write allow read lock（因为MySQL是通过重建表+重命名方式实现ddl）。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨晚半夜处理了一个故障，只是简单SQL执行缺少索引导致CPU飙高，加一条索引就搞定。原来以为事情到此为止，让另外一个同事收尾准备睡觉了，这个时候高潮出现了。刚才处理的是一台slave server，为了保证实例数据对象一致性，让同事先删掉，然后在master server再加这条索引，最后发现add index的操作在slave server一直在等metadata lock释放了，并且在processlist里面居然找不到任何引起表锁的请求。就这样折腾了到凌晨，后面索性就丢在自己等锁释放，差不多过了6分钟创建成功，load再次下降。</p>
<h3 id="分析">分析</h3>
<p>事后在5.5的手册中找到了解释：</p>
<blockquote>
<p>To ensure transaction serializability, the server must not permit one session to perform a data definition language (DDL) statement on a table that is used in an uncompleted transaction in another session. The server achieves this by acquiring metadata locks on tables used within a transaction and deferring release of those locks until the transaction ends. A metadata lock on a table prevents changes to the table’s structure. This locking approach has the implication that a table that is being used by a transaction within one session cannot be used in DDL statements by other sessions until the transaction ends. </p>
</blockquote>
]]>
    
    </summary>
    
      <category term="database" scheme="http://hidba.ga/tags/database/"/>
    
      <category term="MySQL" scheme="http://hidba.ga/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://hidba.ga/2014/09/17/helloworld/"/>
    <id>http://hidba.ga/2014/09/17/helloworld/</id>
    <published>2014-09-17T07:22:11.000Z</published>
    <updated>2014-10-09T01:52:43.000Z</updated>
    <content type="html"><![CDATA[<p>按照惯例好像每个在github上写bolg的人都应该开篇写一章，好吧。<br>自从之前托管在同事的服务器崩溃了，我就好久没再写blog了，时隔好多好多个月，终于又鼓起勇气开始搭建blog。为了偷懒我决定抛弃wp，爱上github，然后然后下面稍微记录下这次搭建的过程，怎么也耗费了我一个下午的上班时间，罪过。<br>另外值得说的是，我是用hexo，而不是Jekyll和Octopress，为毛？简单，模板又多，好吧果然符合我喜欢偷懒的个性。</p>
<a id="more"></a>

<h3 id="环境准备">环境准备</h3>
<ol>
<li>注册github</li>
</ol>
<p>过程忽略</p>
<ol>
<li>安装Node</li>
</ol>
<p>到Node.js官网下载相应平台的<a href="http://nodejs.org/download" target="_blank" rel="external">最新版本</a>，一路安装即可。</p>
<ol>
<li>安装Gitbash</li>
</ol>
<p>原谅我偷懒，google下一大把，我就不再复述。</p>
<h3 id="安装hexo">安装hexo</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="operator"><span class="keyword">install</span> -g hexo</span></div></pre></td></tr></table></figure>

<h3 id="初始化">初始化</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init <span class="tag">&lt;<span class="title">folder</span>&gt;</span></div></pre></td></tr></table></figure>

<p>或者是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> &lt;folder&gt;</div><div class="line"><span class="keyword">cd</span> &lt;folder&gt;</div><div class="line">hexo init</div></pre></td></tr></table></figure>

<h3 id="生成静态页">生成静态页</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">npm <span class="operator"><span class="keyword">install</span></span></div></pre></td></tr></table></figure>

<h3 id="本地启动">本地启动</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">server</span></div></pre></td></tr></table></figure>

<p>然后浏览器输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>就可以看到效果。</p>
<h3 id="写文章">写文章</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">new</span> [layout] <span class="string">"postName"</span> <span class="preprocessor">#新建文章</span></div></pre></td></tr></table></figure>

<h3 id="安装主题">安装主题</h3>
<p>主题列表请见<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">传送门</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/litten</span><span class="regexp">/hexo-theme-yilia.git themes/yilia</span></div></pre></td></tr></table></figure>

<h3 id="常用命令">常用命令</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span> <span class="preprocessor">#新建文章</span></div><div class="line">hexo <span class="keyword">new</span> page <span class="string">"pageName"</span> <span class="preprocessor">#新建页面</span></div><div class="line">hexo generate <span class="preprocessor">#生成静态页面至public目录</span></div><div class="line">hexo <span class="keyword">server</span> <span class="preprocessor">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></div><div class="line">hexo deploy <span class="preprocessor">#将.deploy目录部署到GitHub</span></div></pre></td></tr></table></figure>

<h3 id="目录结构">目录结构</h3>
<pre><code>.
├── .deploy
├── <span class="keyword">public</span>
├── scaffolds
├── scripts
├── <span class="keyword">source</span>
|   ├── _drafts
|   └── _posts
├── themes
├── _config.yml
└── <span class="keyword">package</span>.json
</code></pre><h3 id="发布">发布</h3>
<ol>
<li>配置ssh信任</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen</div></pre></td></tr></table></figure>

<p>然后把生成的秘钥黏贴到github上就OK了，可以这样测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">ssh</span> -T git<span class="variable">@github</span>.com</div></pre></td></tr></table></figure>

<ol>
<li>发布</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo deploy -g</div><div class="line">hexo <span class="keyword">server</span> -g <span class="preprocessor">##本地调试</span></div></pre></td></tr></table></figure>

<h3 id="其他">其他</h3>
<p>说实话这篇文章也是滥竽充数，很多调试的过程都被我忽略了，大家就将就吧，贴几个网址大家有兴趣可以上去看看，绝对比我写的详细。</p>
<blockquote>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">http://ibruce.info/2013/11/22/hexo-your-blog/</a><br><a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">http://blog.fens.me/hexo-blog-github/</a><br><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">https://github.com/litten/hexo-theme-yilia</a> (我的主题)</p>
</blockquote>
<h3 id="基本语法">基本语法</h3>
<h1 id="一级标题">一级标题</h1>
<h2 id="二级标题">二级标题</h2>
<pre><code>无行号代码框
hello world
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">代码框框</div><div class="line">hello <span class="preprocessor">word</span></div></pre></td></tr></table></figure>

<p><strong>加粗</strong></p>
<p><em>斜体</em></p>
<h2 id="下面是分割符">下面是分割符</h2>
<blockquote>
<p>引用内容</p>
</blockquote>
<ol>
<li>无序标题1</li>
<li>无序标题2</li>
<li>无序标题3</li>
</ol>
<p><a href="http://www.baidu.com" target="_blank" rel="external">超链接百度</a><br><img src="http://image-myrock-github-io.qiniudn.com/17173.jpg" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>按照惯例好像每个在github上写bolg的人都应该开篇写一章，好吧。<br>自从之前托管在同事的服务器崩溃了，我就好久没再写blog了，时隔好多好多个月，终于又鼓起勇气开始搭建blog。为了偷懒我决定抛弃wp，爱上github，然后然后下面稍微记录下这次搭建的过程，怎么也耗费了我一个下午的上班时间，罪过。<br>另外值得说的是，我是用hexo，而不是Jekyll和Octopress，为毛？简单，模板又多，好吧果然符合我喜欢偷懒的个性。</p>
]]>
    
    </summary>
    
      <category term="other" scheme="http://hidba.ga/tags/other/"/>
    
  </entry>
  
</feed>
